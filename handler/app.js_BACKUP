"use strict";
const {
	WASocket,
	proto,
	getContentType,
	downloadContentFromMessage,
	decodeJid,
	generateWAMessageFromContent,
	generateWAMessage,
} = require("@adiwajshing/baileys");
const axios = require("axios").default;
const { PassThrough } = require("stream");
const moment = require("moment-timezone");
const ffmpeg = require("fluent-ffmpeg");
const FormData = require("form-data");
const chalk = require("chalk");
const fs = require("fs");
const Math_js = require("mathjs");
const fetch = (...args) =>
	import("node-fetch").then(({ default: fetch }) => fetch(...args));
const ms = require("parse-ms");
const toMS = require("ms");
const xzons = require("xzons-api");
// const hxz = require("hxz-api"); // Unused module
const yts = require("yt-search");
// const xfar = require("xfarr-api"); // Unused module
const request = require("request");
const { exec, spawn } = require("child_process");
let { sizeFormatter } = require("human-readable");
let format = sizeFormatter({
	std: "JEDEC", // 'SI' (default) | 'IEC' | 'JEDEC'
	decimalPlaces: 2,
	keepTrailingZeroes: false,
	render: (literal, symbol) => `${literal} ${symbol}B`,
});

//lib/utils
const { _tokoVoucher } = require("../utils/tokoVoucher.js");
let tokoVoucher = new _tokoVoucher();

const _sewa = require("../utils/sewa");
const afkg = require("../utils/afk");
const {
	Exif,
	imageToWebp,
	videoToWebp,
	writeExifImg,
	writeExifVid,
	writeExif,
} = require("../utils/exif");
const exif = new Exif();
const { allMenu, ownmenu } = require("../utils/help");
const {
	isSetWelcome,
	addSetWelcome,
	changeSetWelcome,
	removeSetWelcome,
} = require("../utils/setwelcome");
const {
	isSetLeft,
	addSetLeft,
	removeSetLeft,
	changeSetLeft,
} = require("../utils/setleft");
const {
	addResponList,
	delResponList,
	resetListAll,
	isAlreadyResponList,
	isAlreadyResponListGroup,
	sendResponList,
	updateResponList,
	getDataResponList,
} = require("../utils/respon-list");
const {
	isSetProses,
	addSetProses,
	removeSetProses,
	changeSetProses,
	getTextSetProses,
} = require("../utils/setproses");
const {
	isSetDone,
	addSetDone,
	removeSetDone,
	changeSetDone,
	getTextSetDone,
} = require("../utils/setdone");
const {
	isSetOpen,
	addSetOpen,
	removeSetOpen,
	changeSetOpen,
	getTextSetOpen,
} = require("../utils/setopen");
const {
	isSetClose,
	addSetClose,
	removeSetClose,
	changeSetClose,
	getTextSetClose,
} = require("../utils/setclose");
const {
	isSetBot,
	addSetBot,
	removeSetBot,
	changeSetBot,
	getTextSetBot,
} = require("../utils/setbot");
const {
	getBuffer,
	serialize,
	getRandom,
	fetchJson,
	runtime,
} = require("../utils/myfunc");
const { smsg, parseMention } = require("../utils/mysim");
let mess = JSON.parse(fs.readFileSync("./utils/mess.json"));
//database
let opengc = JSON.parse(fs.readFileSync("./database/opengc.json"));
let set_bot = JSON.parse(fs.readFileSync("./database/set_bot.json"));
let _afks = JSON.parse(fs.readFileSync("./database/afg.json"));
let db_respon_list = JSON.parse(
	fs.readFileSync("./database/list-message.json")
);
let sewa = JSON.parse(fs.readFileSync("./database/sewa.json"));
let set_proses = JSON.parse(fs.readFileSync("./database/set_proses.json"));
let set_done = JSON.parse(fs.readFileSync("./database/set_done.json"));
let set_open = JSON.parse(fs.readFileSync("./database/set_open.json"));
let set_close = JSON.parse(fs.readFileSync("./database/set_close.json"));
let antilink = JSON.parse(fs.readFileSync("./database/antilink.json"));
let pricelist = JSON.parse(fs.readFileSync("./database/pricelist.json"));
let antiwame = JSON.parse(fs.readFileSync("./database/antiwame.json"));
let antilinkall = JSON.parse(fs.readFileSync("./database/antilinkall.json"));
let downloadfitur = JSON.parse(fs.readFileSync("./database/download.json"));
let mute = JSON.parse(fs.readFileSync("./database/mute.json"));

let merchant = "" // "M230126IKCZ5258FG";
let secret = "" // "e17128f95174675ccc40df56426280ffaafb486f8ea08962646597939daae911";
let sign = "signature";

//END
/**
 *
 * @param { string } text
 * @param { string } color
 */
const color = (text, color) => {
	return !color ? chalk.green(text) : chalk.keyword(color)(text);
};

Array.prototype.random = function () {
	return this[Math.floor(Math.random() * this.length)];
};

/**
 * @param {WASocket} sock
 * @param {proto.IWebMessageInfo} msg
 */
// Bandwidth
async function checkBandwidth() {
	let ind = 0;
	let out = 0;
	for (let i of await require("node-os-utils").netstat.stats()) {
		ind += parseInt(i.inputBytes);
		out += parseInt(i.outputBytes);
	}
	return {
		download: format(ind),
		upload: format(out),
	};
}

moment.tz.setDefault("Asia/Jakarta").locale("id");
module.exports = async (
	sock,
	msg,
	welcome,
	left,
	set_welcome_db,
	set_left_db
) => {
	const {
		ownerNumber,
		ownnumber,
		ownerName,
		pathimg,
		logoafk,
		botName,
		youtubeName,
		youtube,
		apikey,
		owncek,
		footer,
	} = require("../config.json");
	const extendedText = getContentType;
	const setya = sock;
	const gaya = "```";
	const gy = "```";
	let m = serialize(sock, msg);
	let rm = smsg(sock, msg);
	let thumb = fs.readFileSync(pathimg);
	let thum = fs.readFileSync(pathimg);
	let thumafk = fs.readFileSync(logoafk);
	const time = moment().tz("Asia/Jakarta").format("HH:mm:ss");
	const tanggal = moment().tz("Asia/Jakarta").format("dddd, ll");
	let timestamp = `${time}${tanggal}`;
	const jam = moment().format("HH:mm:ss z");
	let dt = moment(Date.now()).tz("Asia/Jakarta").locale("id").format("a");
	var fildt =
		dt == "pagi"
			? dt + "🌝"
			: dt == "siang"
			? dt + "🌞"
			: dt == "sore"
			? dt + "🌝"
			: dt + "🌚";
	const ucapanWaktu = fildt.charAt(0).toUpperCase() + fildt.slice(1);
	if (msg.key && msg.key.remoteJid === "status@broadcast") return;
	if (!msg.message) return;

	const type = getContentType(msg.message);
	const quotedType =
		getContentType(
			msg.message?.extendedTextMessage?.contextInfo?.quotedMessage
		) || null;
	if (type == "ephemeralMessage") {
		msg.message = msg.message.ephemeralMessage.message;
		msg.message = msg.message.ephemeralMessage.message.viewOnceMessage;
	}
	if (type == "viewOnceMessage") {
		msg.message = msg.message.viewOnceMessage.message;
	}

	const botId = sock.user.id.includes(":")
		? sock.user.id.split(":")[0] + "@s.whatsapp.net"
		: sock.user.id;

	const botNumber = await sock.decodeJid(sock.user.id);
	const from = msg.key.remoteJid;
	const rizkyy =
		type === "conversation" && msg.message.conversation
			? msg.message.conversation
			: type == "imageMessage" && msg.message.imageMessage.caption
			? msg.message.imageMessage.caption
			: type == "documentMessage" && msg.message.documentMessage.caption
			? msg.message.documentMessage.caption
			: type == "videoMessage" && msg.message.videoMessage.caption
			? msg.message.videoMessage.caption
			: type == "extendedTextMessage" && msg.message.extendedTextMessage.text
			? msg.message.extendedTextMessage.text
			: type == "buttonsResponseMessage" &&
			  msg.message.buttonsResponseMessage.selectedButtonId
			? msg.message.buttonsResponseMessage.selectedButtonId
			: type == "templateButtonReplyMessage" &&
			  msg.message.templateButtonReplyMessage.selectedId
			? msg.message.templateButtonReplyMessage.selectedId
			: type == "listResponseMessage"
			? msg.message.listResponseMessage.singleSelectReply.selectedRowId
			: type == "messageContextInfo"
			? msg.message.listResponseMessage.singleSelectReply.selectedRowId
			: "";
	const body =
		type == "conversation"
			? msg.message?.conversation
			: msg.message[type]?.caption || msg.message[type]?.text || "";
	const chata =
		type === "conversation" && msg.message.conversation
			? msg.message.conversation
			: type == "imageMessage" && msg.message.imageMessage.caption
			? msg.message.imageMessage.caption
			: type == "documentMessage" && msg.message.documentMessage.caption
			? msg.message.documentMessage.caption
			: type == "videoMessage" && msg.message.videoMessage.caption
			? msg.message.videoMessage.caption
			: type == "extendedTextMessage" && msg.message.extendedTextMessage.text
			? msg.message.extendedTextMessage.text
			: type == "buttonsResponseMessage" &&
			  msg.message.buttonsResponseMessage.selectedButtonId
			? msg.message.buttonsResponseMessage.selectedButtonId
			: type == "templateButtonReplyMessage" &&
			  msg.message.templateButtonReplyMessage.selectedId
			? msg.message.templateButtonReplyMessage.selectedId
			: type == "listResponseMessage"
			? msg.message.listResponseMessage.singleSelectReply.selectedRowId
			: type == "messageContextInfo"
			? msg.message.listResponseMessage.singleSelectReply.selectedRowId
			: "";
	const responseMessage =
		type == "listResponseMessage"
			? msg.message?.listResponseMessage?.singleSelectReply?.selectedRowId || ""
			: type == "buttonsResponseMessage"
			? msg.message?.buttonsResponseMessage?.selectedButtonId || ""
			: "";
	const isGroup = from.endsWith("@g.us");
	const budy =
		type === "conversation"
			? msg.message.conversation
			: type === "extendedTextMessage"
			? msg.message.extendedTextMessage.text
			: "";

	var sender = isGroup ? msg.key.participant : msg.key.remoteJid;
	console.log(sender);
	sender = sender.includes(":")
		? sender.split(":")[0] + "@s.whatsapp.net"
		: sender;
	const senderName = msg.pushName;
	const senderNumber = sender.split("@")[0];
	const pushname = msg.pushName;

	const groupMetadata = isGroup ? await sock.groupMetadata(from) : null;
	const groupName = groupMetadata?.subject || "";
	const groupMembers = groupMetadata?.participants || [];
	const groupAdmins = groupMembers.filter((v) => v.admin).map((v) => v.id);

	const isCmd = /^[°•π÷×¶∆£¢€¥®™✓_=|~!?#/$%^&.+-,\\\©^]/.test(chata);
	const prefix = isCmd ? body[0] : "";
	const isGroupAdmins = groupAdmins.includes(sender);
	const isBotGroupAdmins = groupMetadata && groupAdmins.includes(botId);
	const isOwner = [...ownerNumber]
		.map((jid) => jid.replace(/[^0-9]/g, "") + "@s.whatsapp.net")
		.includes(msg.sender);
	
	const isDev = ownerNumber.includes(sender);
	const Xcommand = chata.toLowerCase().split(" ")[0] || "";
	const XisCmd = Xcommand.startsWith(prefix);

	let command = isCmd
		? chata.slice(1).trim().split(" ").shift().toLowerCase()
		: "";
	let responseId =
		msg.message?.listResponseMessage?.singleSelectReply?.selectedRowId ||
		msg.message?.buttonsResponseMessage?.selectedButtonId ||
		null;
	let args = body.trim().split(" ").slice(1);
	let full_args = body.replace(command, "").slice(1).trim();
	let q = args.join(" ");
	const argr = rizkyy.split(" ");

	const isMuted = isGroup ? (mute.includes(from) ? true : false) : false;
	const isDownload = downloadfitur.includes(from) ? true : false;
	const isAfkOn = afkg.checkAfkUser(sender, _afks);
	const isAntiLink = antilink.includes(from) ? true : false;
	const isAntiLinkAll = antilinkall.includes(from) ? true : false;
	const isAntiWame = antiwame.includes(from) ? true : false;
	const isPricelist = pricelist.includes(from) ? true : false;
	const isSewa = _sewa.checkSewaGroup(from, sewa);
	const isWelcome = isGroup ? (welcome.includes(from) ? true : false) : false;
	const isLeft = isGroup ? (left.includes(from) ? true : false) : false;
	const mentionByTag =
		type == "extendedTextMessage" &&
		msg.message.extendedTextMessage.contextInfo != null
			? msg.message.extendedTextMessage.contextInfo.mentionedJid
			: [];
	const mentionByReply =
		type == "extendedTextMessage" &&
		msg.message.extendedTextMessage.contextInfo != null
			? msg.message.extendedTextMessage.contextInfo.participant || ""
			: "";
	const mention =
		typeof mentionByTag == "string" ? [mentionByTag] : mentionByTag;
	mention != undefined ? mention.push(mentionByReply) : [];
	const mentionUser = mention != undefined ? mention.filter((n) => n) : [];
	let mentioned =
		msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];

	async function downloadAndSaveMediaMessage(type_file, path_file) {
		if (type_file === "image") {
			var stream = await downloadContentFromMessage(
				msg.message.imageMessage ||
					msg.message.extendedTextMessage?.contextInfo.quotedMessage
						.imageMessage,
				"image"
			);
			let buffer = Buffer.from([]);
			for await (const chunk of stream) {
				buffer = Buffer.concat([buffer, chunk]);
			}
			fs.writeFileSync(path_file, buffer);
			return path_file;
		} else if (type_file === "video") {
			var stream = await downloadContentFromMessage(
				msg.message.videoMessage ||
					msg.message.extendedTextMessage?.contextInfo.quotedMessage
						.videoMessage,
				"video"
			);
			let buffer = Buffer.from([]);
			for await (const chunk of stream) {
				buffer = Buffer.concat([buffer, chunk]);
			}
			fs.writeFileSync(path_file, buffer);
			return path_file;
		} else if (type_file === "sticker") {
			var stream = await downloadContentFromMessage(
				msg.message.stickerMessage ||
					msg.message.extendedTextMessage?.contextInfo.quotedMessage
						.stickerMessage,
				"sticker"
			);
			let buffer = Buffer.from([]);
			for await (const chunk of stream) {
				buffer = Buffer.concat([buffer, chunk]);
			}
			fs.writeFileSync(path_file, buffer);
			return path_file;
		} else if (type_file === "audio") {
			var stream = await downloadContentFromMessage(
				msg.message.audioMessage ||
					msg.message.extendedTextMessage?.contextInfo.quotedMessage
						.audioMessage,
				"audio"
			);
			let buffer = Buffer.from([]);
			for await (const chunk of stream) {
				buffer = Buffer.concat([buffer, chunk]);
			}
			fs.writeFileSync(path_file, buffer);
			return path_file;
		}
	}

	async function sendStickerFromUrl(
		from,
		url,
		packname1 = stc.packname,
		author1 = stc.author,
		options = {}
	) {
		var names = Date.now() / 10000;
		var download = function (uri, filename, callback) {
			request.head(uri, function (err, res, body) {
				request(uri).pipe(fs.createWriteStream(filename)).on("close", callback);
			});
		};
		exif.create(packname1, author1, `sendstc_${names}`);
		download(url, "./temp/" + names + ".png", async function () {
			let filess = "./temp/" + names + ".png";
			let asw = "./temp/" + names + ".webp";
			exec(
				`ffmpeg -i ${filess} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${asw}`,
				async (err) => {
					exec(
						`webpmux -set exif ./temp/sendstc_${names}.exif ${asw} -o ${asw}`,
						async (error) => {
							setya.sendMessage(
								from,
								{ sticker: fs.readFileSync(asw) },
								options
							);
							fs.unlinkSync(filess);
							fs.unlinkSync(asw);
						}
					);
				}
			);
		});
	}

	const sendFileFromUrl = async (from, url, caption, options = {}) => {
		let mime = "";
		let res = await axios.head(url);
		mime = res.headerd["content-type"];
		let type = mime.split("/")[0] + "Message";
		if (mime.split("/")[0] === "image") {
			var img = await getBuffer(url);
			return setya.sendMessage(from, { image: img, caption: caption }, options);
		} else if (mime.split("/")[0] === "video") {
			var vid = await getBuffer(url);
			return setya.sendMessage(from, { video: vid, caption: caption }, options);
		} else if (mime.split("/")[0] === "audio") {
			var aud = await getBuffer(url);
			return setya.sendMessage(
				from,
				{ audio: aud, mimetype: "audio/mp3" },
				options
			);
		} else {
			var doc = await getBuffer(url);
			return setya.sendMessage(
				from,
				{ document: doc, mimetype: mime, caption: caption },
				options
			);
		}
	};

	//jeda time
	setInterval(() => {
		for (let i of Object.values(opengc)) {
			if (Date.now() >= i.time) {
				setya
					.groupSettingUpdate(i.id, "not_announcement")
					.then((res) =>
						setya.sendMessage(i.id, { text: `Waktu Jeda Telah Selesai` })
					)
					.catch((err) => setya.sendMessage(i.id, { text: "Error" }));
				delete opengc[i.id];
				fs.writeFileSync("./database/opengc.json", JSON.stringify(opengc));
			}
		}
	}, 1000);

	setya.createMessage = async (jidnya, kontennya, optionnya) => {
		return await generateWAMessage(jidnya, kontennya, {
			...optionnya,
			userJid: setya.authState.creds.me.id,
			upload: setya.waUploadToServer,
		});
	};

	const isImage = type == "imageMessage";
	const isVideo = type == "videoMessage";
	const isAudio = type == "audioMessage";
	const isSticker = type == "stickerMessage";
	const isContact = type == "contactMessage";
	const isLocation = type == "locationMessage";

	const isQuoted = type == "extendedTextMessage";
	const isQuotedImage = isQuoted && quotedType == "imageMessage";
	const isQuotedVideo = isQuoted && quotedType == "videoMessage";
	const isQuotedAudio = isQuoted && quotedType == "audioMessage";
	const isQuotedSticker = isQuoted && quotedType == "stickerMessage";
	const isQuotedContact = isQuoted && quotedType == "contactMessage";
	const isQuotedLocation = isQuoted && quotedType == "locationMessage";

	var mediaType = type;
	var stream;
	if (isQuotedImage || isQuotedVideo || isQuotedAudio || isQuotedSticker) {
		mediaType = quotedType;
		msg.message[mediaType] =
			msg.message.extendedTextMessage.contextInfo.quotedMessage[mediaType];
		stream = await downloadContentFromMessage(
			msg.message[mediaType],
			mediaType.replace("Message", "")
		).catch(console.error);
	}

	//SEWA WAKTU
	_sewa.expiredCheck(setya, sewa);

	if (!isGroup && !isCmd)
		console.log(
			color(`[ ${time} ]`, "white"),
			color("[ PRIVATE ]", "aqua"),
			color(body.slice(0, 50), "white"),
			"from",
			color(senderNumber, "yellow")
		);
	if (isGroup && !isCmd)
		console.log(
			color(`[ ${time} ]`, "white"),
			color("[  GROUP  ]", "aqua"),
			color(body.slice(0, 50), "white"),
			"from",
			color(senderNumber, "yellow"),
			"in",
			color(groupName, "yellow")
		);
	if (!isGroup && isCmd)
		console.log(
			color(`[ ${time} ]`, "white"),
			color("[ COMMAND ]", "aqua"),
			color(body, "white"),
			"from",
			color(senderNumber, "yellow")
		);
	if (isGroup && isCmd)
		console.log(
			color(`[ ${time} ]`, "white"),
			color("[ COMMAND ]", "aqua"),
			color(body, "white"),
			"from",
			color(senderNumber, "yellow"),
			"in",
			color(groupName, "yellow")
		);

	function hitungmundur(bulan, tanggal) {
		let from = new Date(`${bulan} ${tanggal}, 2022 00:00:00`).getTime();
		let now = Date.now();
		let distance = from - now;
		let days = Math.floor(distance / (1000 * 60 * 60 * 24));
		let hours = Math.floor(
			(distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)
		);
		let minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
		let seconds = Math.floor((distance % (1000 * 60)) / 1000);
		return (
			days + "Hari " + hours + "Jam " + minutes + "Menit " + seconds + "Detik"
		);
	}

	var { download, upload } = await checkBandwidth();
	let mundur = hitungmundur(7, 9);
	var menunya = allMenu(
		ucapanWaktu,
		pushname,
		mundur,
		upload,
		download,
		ownerName,
		youtubeName,
		botName,
		jam,
		tanggal,
		isOwner,
		sender,
		prefix
	);

	const reply = async (text) => {
		return sock.sendMessage(from, { text: text.trim() }, { quoted: msg });
	};

	function jsonformat(string) {
		return JSON.stringify(string, null, 2);
	}

	const isUrl = (url) => {
		return url.match(
			new RegExp(
				/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)/,
				"gi"
			)
		);
	};

	const sendContact = (jid, numbers, name, quoted, mn) => {
		let number = numbers.replace(/[^0-9]/g, "");
		const vcard =
			"BEGIN:VCARD\n" +
			"VERSION:3.0\n" +
			"FN:" +
			name +
			"\n" +
			"ORG:;\n" +
			"TEL;type=CELL;type=VOICE;waid=" +
			number +
			":+" +
			number +
			"\n" +
			"END:VCARD";
		return setya.sendMessage(
			from,
			{
				contacts: { displayName: name, contacts: [{ vcard }] },
				mentions: mn ? mn : [],
			},
			{ quoted: quoted }
		);
	};

	const isEmoji = (emo) => {
		let emoji_ranges =
			/(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/g;
		let regexEmoji = new RegExp(emoji_ranges, "gi");
		return emo.match(regexEmoji);
	};

	async function getGcName(groupID) {
		try {
			let data_name = await setya.groupMetadata(groupID);
			return data_name.subject;
		} catch (err) {
			return "*Group Tidak Ada*";
		}
	}

	function mentions(teks, mems = [], id) {
		if (id == null || id == undefined || id == false) {
			let res = setya.sendMessage(from, { text: teks, mentions: mems });
			return res;
		} else {
			let res = setya.sendMessage(
				from,
				{ text: teks, mentions: mems },
				{ quoted: msg }
			);
			return res;
		}
	}

	const sendOrder = async (
		jid,
		text,
		orid,
		img,
		itcount,
		title,
		sellers,
		tokens,
		ammount
	) => {
		const order = generateWAMessageFromContent(
			jid,
			proto.Message.fromObject({
				orderMessage: {
					orderId: orid, // Ganti Idnya
					thumbnail: img, // Ganti Imagenya
					itemCount: itcount, // Ganti Item Countnya
					status: "INQUIRY", // Jangan Diganti
					surface: "CATALOG", // Jangan Diganti
					orderTitle: title, // Ganti Titlenya
					message: text, // Ganti Messagenya
					sellerJid: sellers, // Ganti sellernya
					token: tokens, // Ganti tokenya
					totalAmount1000: ammount, // Ganti Total Amountnya
					totalCurrencyCode: "IDR", // Terserah
				},
			}),
			{ userJid: jid }
		);
		setya.relayMessage(jid, order.message, { messageId: order.key.id });
	};

	//MULAI AFK
	if (isGroup) {
		for (let x of mentionUser) {
			if (afkg.checkAfkUser(x, _afks)) {
				const getId = afkg.getAfkId(x, _afks);
				const getReason = afkg.getAfkReason(getId, _afks);
				const getTime = afkg.getAfkTime(getId, _afks);
				//if (riz.message.extendedTextMessage != undefined){
				try {
					var afpk = await setya.profilePictureUrl(mentionUser[0], "image");
				} catch {
					var afpk = "https://i.ibb.co/Twkhgy9/images-4.jpg";
				}
				var thumeb = await getBuffer(afpk);
				const cptl = `*ꞌꞋ ࣪𓂃 ִֶָ Admin Afk ִֶָ 𓂃 ࣪ꞌꞋ*

O  Saat Ini @${mentionUser[0].split("@")[0]} Sedang Offline/Afk
O *Alasan*  : ${getReason}
O *Afk Sejak* : ${getTime}`;
				setya.sendMessage(
					from,
					{
						text: cptl,
						contextInfo: {
							mentionedJid: [mentionUser],
							externalAdReply: {
								title: `SEDANG OFFLINE`,
								body: "Mode Afk Aktif",
								thumbnail: thumafk,
								sourceUrl: `https://wa.me/${x}`,
								mediaUrl: "",
								renderLargerThumbnail: true,
								showAdAttribution: false,
								mediaType: 1,
							},
						},
					},
					{ quoted: m }
				);
				//sendMess(x, `Assalamualaikum\n\n_Ada Yg Mencari Kamu Saat Kamu Offline/Afk_\n\nNama : ${pushname}\nNomor : wa.me/${sender.split("@")[0]}\nDi Group : ${groupName}\nPesan : ${chata}`)
			}
		}
		//KEMBALI DARI AFK
		if (afkg.checkAfkUser(sender, _afks)) {
			const getTime = afkg.getAfkTime(sender, _afks);
			const getReason = afkg.getAfkReason(sender, _afks);
			const ittung = ms((await Date.now()) - getTime);
			try {
				var afpkk = await setya.profilePictureUrl(mentionUser[0], "image");
			} catch {
				var afpkk = "https://i.ibb.co/Twkhgy9/images-4.jpg";
			}
			var thumbw = await getBuffer(afpkk);
			const pep = `*${pushname}* Telah Kembali Dari Afknya!`;
			setya.sendMessage(
				from,
				{
					text: pep,
					contextInfo: {
						mentionedJid: [sender],
						externalAdReply: {
							title: `KEMBALI ONLINE`,
							body: "Mode Afk Nonaktif",
							thumbnail: thumafk,
							sourceUrl: `https://wa.me/${sender}`,
							mediaUrl: "",
							renderLargerThumbnail: true,
							showAdAttribution: false,
							mediaType: 1,
						},
					},
				},
				{ quoted: m }
			);
			_afks.splice(afkg.getAfkPosition(sender, _afks), 1);
			fs.writeFileSync("./database/afkg.json", JSON.stringify(_afks));
		}
	}

	const replyDeface = (teks) => {
		return setya.sendMessage(
			from,
			{
				text: teks,
				contextInfo: {
					externalAdReply: {
						title: `${botName}`,
						body: `Multi Device`,
						mediaType: 2,
						thumbnail: thumb,
						sourceUrl: `https://wa.me/${owncek}`,
					},
				},
			},
			{ quoted: msg }
		);
	};
	setya.readMessages([msg.key]);

	setya.sendPresenceUpdate("available", from);
	if (chata.startsWith("=>") && isOwner) {
		let evaled,
			text = chata.replace("=>", ""),
			{ inspect } = require("util");
		try {
			if (text.endsWith("--sync")) {
				evaled = await eval(
					`(async () => { ${text.trim.replace("--sync", "")} })`
				);
				msg.reply(evaled);
			}
			evaled = await eval(text);
			if (typeof evaled !== "string") evaled = inspect(evaled);
			await sock.sendMessage(msg.from, { text: evaled }, { quoted: msg });
		} catch (e) {
			sock.sendMessage(msg.from, { text: String(e) }, { quoted: msg });
		}
	}
	// Detect Group Invite
	if (m.mtype === "groupInviteMessage") {
		var eyeye = `*Jika Ingin Bot Masuk Ke Group Mu Silahkan Sewabot Ke Owner Dengan Ketik :* #owner`;
		setya.sendMessage(
			from,
			{
				text: eyeye,
				contextInfo: {
					externalAdReply: {
						title: `${ucapanWaktu} ${pushname}`,
						body: "BOT MD",
						thumbnail: thum,
						mediaType: 1,
						renderLargerThumbnail: false,
						showAdAttribution: true,
						mediaUrl: "https://chat.whatsapp.com/Kpy1GjLe33PVfbMYXJx4",
						sourceUrl: "https://chat.whatsapp.com/Kpy1GjLe33P0VfbYXJx4",
					},
				},
			},
			{ quoted: m }
		);
	}

	//AntiLink
	if (isGroup && isAntiLink && !isOwner && !isGroupAdmins && isBotGroupAdmins) {
		if (budy.match(/(https:\/\/chat.whatsapp.com)/gi)) {
			if (!isBotGroupAdmins)
				return replyDeface(`*Selama Bot Bukan Admin Kirim Lah Link Sesuka Mu*`);
			replyDeface(
				`*「 LINKGROUP DETECTOR 」*\n\n karena kamu melanggar aturan group, yaitu menggirim link group kamu akan di kick dari group! bye bye:)`
			);
			setya.groupParticipantsUpdate(from, [sender], "remove");
		}
	}
	if (isGroup && isAntiLink && !isOwner && !isGroupAdmins && isBotGroupAdmins) {
		if (budy.match("chat.whatsapp.com/")) {
			if (!isBotGroupAdmins)
				return replyDeface(`*Selama Bot Bukan Admin Kirim Lah Link Sesuka Mu*`);
			replyDeface(
				`*「 LINKGROUP DETECTOR 」*\n\n karena kamu melanggar aturan group, yaitu menggirim link group kamu akan di kick dari group! bye bye:)`
			);
			setya.groupParticipantsUpdate(from, [sender], "remove");
		}
	}
	//Antilinkwame
	if (isGroup && isAntiWame && !isOwner && !isGroupAdmins && isBotGroupAdmins) {
		if (chata.match(/(wa.me)/gi)) {
			if (!isBotGroupAdmins)
				return replyDeface(`*Selama Bot Bukan Admin Kirim Lah Link Sesuka Mu*`);
			replyDeface(
				`*「  LINK WA ME DETECTOR 」*\n\nSepertinya kamu mengirimkan link wa me, maaf kamu akan di kick`
			);
			setya.groupParticipantsUpdate(from, [sender], "remove");
		}
	}
	if (isGroup && isAntiWame && !isOwner && !isGroupAdmins && isBotGroupAdmins) {
		if (budy.match(/(https:\/\/wa.me)/gi)) {
			if (!isBotGroupAdmins)
				return replyDeface(`*Selama Bot Bukan Admin Kirim Lah Link Sesuka Mu*`);
			replyDeface(
				`*「 LINK WA ME DETECTOR 」*\n\nSepertinya kamu mengirimkan link wa me, maaf kamu akan di kick`
			);
			setya.groupParticipantsUpdate(from, [sender], "remove");
		}
	}
	if (
		isGroup &&
		isAntiLinkAll &&
		!isOwner &&
		!isGroupAdmins &&
		isBotGroupAdmins
	) {
		if (budy.match("https://")) {
			if (!isBotGroupAdmins)
				return replyDeface(`*Selama Bot Bukan Admin Kirim Lah Link Sesuka Mu*`);
			reply(
				`*「 LINK DETECTOR 」*\n\n karena kamu melanggar aturan group, yaitu menggirim link kamu akan di kick dari group! bye bye:)`
			);
			setya.groupParticipantsUpdate(from, [sender], "remove");
		}
	}
	if (
		isGroup &&
		isAntiLinkAll &&
		!isOwner &&
		!isGroupAdmins &&
		isBotGroupAdmins
	) {
		if (budy.match("http://")) {
			if (!isBotGroupAdmins)
				return replyDeface(`*Selama Bot Bukan Admin Kirim Lah Link Sesuka Mu*`);
			reply(
				`*「 LINK DETECTOR 」*\n\n karena kamu melanggar aturan group, yaitu menggirim link kamu akan di kick dari group! bye bye:)`
			);
			setya.groupParticipantsUpdate(from, [sender], "remove");
		}
	}
	if (
		isGroup &&
		isAntiLinkAll &&
		!isOwner &&
		!isGroupAdmins &&
		isBotGroupAdmins
	) {
		if (budy.match(".com")) {
			if (!isBotGroupAdmins)
				return replyDeface(`*Selama Bot Bukan Admin Kirim Lah Link Sesuka Mu*`);
			reply(
				`*「 LINK DETECTOR 」*\n\n karena kamu melanggar aturan group, yaitu menggirim link kamu akan di kick dari group! bye bye:)`
			);
			setya.groupParticipantsUpdate(from, [sender], "remove");
		}
	}
	// Store Respon
	if (!isCmd && isGroup && isAlreadyResponList(from, chata, db_respon_list)) {
		var get_data_respon = getDataResponList(from, chata, db_respon_list);
		if (get_data_respon.isImage === false) {
			setya.sendMessage(
				from,
				{ text: sendResponList(from, chata, db_respon_list) },
				{
					quoted: msg,
				}
			);
		} else {
			setya.sendMessage(
				from,
				{
					image: await getBuffer(get_data_respon.image_url),
					caption: get_data_respon.response,
				},
				{
					quoted: msg,
				}
			);
		}
	}

	// MUTE
	if (isMuted) {
		if (!isGroupAdmins && !isOwner) return;
		if (chata.toLowerCase().startsWith(prefix + "unmute" && prefix + "boton")) {
			let anu = mute.indexOf(from);
			mute.splice(anu, 1);
			fs.writeFileSync("./database/mute.json", JSON.stringify(mute));
			reply(`Sukses Online Di Group ${groupName}`);
		}
	}

	let epep;
	const webHook = async(who, ref_id, _quo, {
		game,
		nick,
		oid,
		item,
		date,
	}) => {
		const md5 = require("md5")
		const API_URL_TRX = "https://api.tokovoucher.id/v1/transaksi/status";
		let MSG_ = `*[ Transaksi %status ]*
*› Game* : ${game}
${nick ? `*› Nickname* : ${nick}` : ""}
*› Order ID* : ${oid}
*› Item* : ${item}
*› Date* : ${date}
*› RefId* : ${ref_id}

%msg

_*${botName}*_
`.trim()

		const __sleep = async (ms) => {
			return new Promise((resolve) => setTimeout(resolve, ms));
		}
		let count = 0;
		while (true) {
			try {
				const { data } = await axios.get(API_URL_TRX, {
					params: {
						ref_id: ref_id,
						member_code: tokoVoucher.member_code,
						signature: md5(`${tokoVoucher.member_code}:${tokoVoucher.secret}:${ref_id}`)
					}
				})
				if (data.status === "gagal") {
					sock.sendMessage(who, {
						text: MSG_
							.replace(/%status/, "GAGAL")
							.replace(/%msg/, "*Transaksi Gagal Dilakukan*")
					}, { quoted: _quo })
					break
				}
				if (data.status === "sukses") {
					sock.sendMessage(who, {
						text: MSG_
							.replace(/%status/, "BERHASIL")
							.replace(/%msg/, "*Terima Kasih Sudah Order*")
					}, { quoted: _quo })
					break
				}
				if (data.status === 0) {
					sock.sendMessage(who, {
						text: MSG_
							.replace(/%status/, "ERROR")
							.replace(/%msg/, "Signature Error!\nTransaksi Gagal Dilakukan")
					}, { quoted: _quo })
					break
				}
			} catch (e) {
				console.log(e)
				sock.sendMessage(who, {
					text: "Koneksi ke API gagal"
				}, { quoted: _quo })
				break
			}
			count = count + 1
			if (count > 9000) {
				console.log(data)
				sock.sendMessage(who, {
						text: MSG_
							.replace(/%status/, "*ERROR	*")
							.replace(/%msg/, "*Gagal mendapat response*")
					}, { quoted: _quo })
				break;
			}
		}
	}
 	switch (command) {
		case "help":
		case "fitur":
			let buttonns = [
				{
					buttonId: `${prefix}owner`,
					buttonText: { displayText: "🧑‍🎤Owner" },
					type: 1,
				},
				{
					buttonId: `${prefix}ceksewa`,
					buttonText: { displayText: "⏰Checksewa" },
					type: 1,
				},
			];
			let buttonMessage = {
				document: fs.readFileSync("./temp/setya.mp4"),
				mimetype: "video/mp4",
				fileName: ucapanWaktu + " " + pushname,
				fileLength: 924,
				caption: menunya,
				footer: `${footer}`,
				buttons: buttonns,
				headerType: 4,
				contextInfo: {
					externalAdReply: {
						title: `${botName}`,
						body: "Bot Multi Device",
						thumbnail: thum,
						sourceUrl: `https://wa.me/${owncek}`,
						mediaUrl: `https://wa.me/${owncek}`,
						renderLargerThumbnail: true,
						showAdAttribution: true,
						mediaType: 1,
					},
				},
			};
			setya.sendMessage(from, buttonMessage, { quoted: msg });
			break;

		case "ownmenu":
			setya.sendMessage(
				from,
				{
					text: ownmenu,
					contextInfo: {
						externalAdReply: {
							title: `RPLBOT V 3〽️`,
							body: "Jangan Lupa Subscribe",
							thumbnail: thum,
							sourceUrl: "https://youtube.com/channel/UCczddkGMmujyvcQXFunUWuQ",
							mediaUrl: "",
							renderLargerThumbnail: true,
							showAdAttribution: false,
							mediaType: 1,
						},
					},
				},
				{ quoted: m }
			);
			break;

		case "afk":
			if (!isGroupAdmins && !isOwner) return reply(mess.GrupAdmin);
			if (!isGroup) return;
			if (isAfkOn) return reply("Kalo Mau Afk Jangan Balas Chat Tai");
			const reason = q ? q : "*No Pesan*";
			afkg.addAfkUser(sender, time, reason, _afks);
			const aluty = `*ꞌꞋ ࣪𓂃 ִֶָ Admin Afk ִֶָ 𓂃 ࣪ꞌꞋ*

${pushname} Sekarang Offline/Afk
O *Alasan*  : ${reason}
O *Mulay Afk* : ${time}`;
			//setya.sendMessage(from, aluty, text)
			setya.sendMessage(
				from,
				{
					text: aluty,
					contextInfo: {
						externalAdReply: {
							title: `MODE AFK ON`,
							body: "Saat Ini Kamu Afk",
							thumbnail: thumafk,
							sourceUrl: `https://wa.me/${sender}`,
							mediaUrl: "",
							renderLargerThumbnail: true,
							showAdAttribution: false,
							mediaType: 1,
						},
					},
				},
				{ quoted: m }
			);
			break;

		// Store Menu
		case "menu":
		case "list":
			if (!isGroup) return reply(mess.OnlyGrup);
			if (db_respon_list.length === 0)
				return reply(`Belum ada list message di database`);
			if (!isAlreadyResponListGroup(from, db_respon_list))
				return reply(
					`Belum ada list message yang terdaftar di group ini\n\n*Untuk Melihat Fitur Bot Ketik* ${prefix}help`
				);
			var arr_rows = [];
			for (let x of db_respon_list) {
				if (x.id === from) {
					arr_rows.push({
						title: x.key,
						rowId: x.key,
					});
				}
			}
			var listMsg = {
				text: `${ucapanWaktu} @${sender.split("@")[0]}`,
				buttonText: "Klik Disini!",
				footer: `Silahkan Pilih Produknya\n\nHalo kak🌟 @${
					sender.split("@")[0]
				}\n📝 *List Menu:* *${groupName}*\n⏳ Waktu: ${jam}\n📆 Tanggal : ${tanggal}`,
				mentions: [sender],
				sections: [
					{
						title: groupName,
						rows: arr_rows,
					},
				],
			};
			setya.sendMessage(from, listMsg);
			//sendOrder(from, listMsg, "3836", thum, 2022, "MENU PRICELIST", `${owncek}@s.whatsapp.net`, "AR6ebQf7wTuyXrVneA0kUMMbQe67ikT6LZrwT2uge7wIEw==", "9783")
			break;
		case "addlist":
			if (!isGroup) return reply(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return reply(mess.GrupAdmin);
			const [__args1, __args2] = q.split("@");
			if (!q.includes("@"))
				return reply(
					`_Cara Addlist Dengan Benar_\n\n.addlist Namalist@Listnya\n\nContoh :\n.addlist EPEP@5 💎 801\n20 💎 2.670\n50 💎 6.408\n70 💎 8.811\n\n_Lakukan Dengan Benar Jangan Sampe Salah_`
				);
			if (isAlreadyResponList(from, __args1, db_respon_list))
				return reply(
					`List respon dengan key : *${__args1}* sudah ada di group ini.`
				);
			if (isImage || isQuotedImage) {
				let media = await downloadAndSaveMediaMessage(
					"image",
					`./temp/stickers/${sender}`
				);
				const fd = new FormData();
				const imgbbUploader = require("imgbb-uploader");
				fd.append("file", fs.readFileSync(media), ".tmp", ".jpg");
				await imgbbUploader(
					"0d434733a8620f34c2183b09af2b135d",
					`./temp/stickers/${sender}`
				).then((data) => {
					addResponList(
						from,
						__args1,
						__args2,
						true,
						`${data.display_url}`,
						db_respon_list
					);
					reply(`*Sukses Set List Massage*\n*Kata Kunci :* *${__args1}*`);
					if (fs.existsSync(media)) fs.unlinkSync(media);
				});
			} else {
				addResponList(from, __args1, __args2, false, "-", db_respon_list);
				reply(`*Sukses Set List Massage*\n*Kata Kunci :* *${__args1}*`);
			}
			break;
		case "dellist":
			if (!isGroup) return reply(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return reply(mess.GrupAdmin);
			if (db_respon_list.length === 0)
				return reply(`Belum ada list message di database`);
			if (!q)
				return reply(
					`_Cara Delete List_\n\n.dellist [Nama List Yg Ingin Di Hapus]\n\nContoh :\n.dellist EPEP\n\n_Lakukan Dengan Benar Jangan Sampe Salah_`
				);
			if (!isAlreadyResponList(from, q, db_respon_list))
				return reply(`List respon dengan key *${q}* tidak ada di database!`);
			delResponList(from, q, db_respon_list);
			reply(`Sekses Delete List *${q}*`);
			break;
		case "resetlistall":
			if (!isGroup) return reply(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return reply(mess.GrupAdmin);
			if (db_respon_list.length === 0)
				return reply(`Belum Ada List Di Group Ini`);
			resetListAll(from, db_respon_list);
			reply(`Sekses Delete All List*`);
			break;
		case "dellist2":
			if (!isGroup) return reply(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return reply(mess.GrupAdmin);
			if (db_respon_list.length === 0)
				return reply(`Belum ada list message di database`);
			var uturu = q.split("@")[0];
			if (!q)
				return reply(
					`Gunakan dengan cara ${command} *key*\n\n_Contoh_\n\n${command} hello`
				);
			if (!isAlreadyResponList(from, uturu, db_respon_list))
				return reply(`List respon dengan key *${q}* tidak ada di database!`);
			delResponList(from, uturu, db_respon_list);
			reply(`Sekses Delete List *${q}*`);
			break;
		case "updatelist":
		case "update":
			if (!isGroup) return reply(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return reply(mess.GrupAdmin);
			const _args1 = q.split("@")[0];
			const _args2 = q.split("@")[1];
			if (!q.includes("@"))
				return reply(
					`_Cara Update List_\n\n.update Namalist@ListBaru\n\nContoh :\n.update EPEP@100 💎 12.816\n140 💎 17.622\n210 💎 26.433\n280 💎 35.244\n\n_Lakukan Dengan Benar Jangan Sampe Salah_`
				);
			if (!isAlreadyResponListGroup(from, db_respon_list))
				return reply(`Maaf, untuk key *${_args1}* belum terdaftar di group ini`);
			if (isImage || isQuotedImage) {
				let media = await downloadAndSaveMediaMessage(
					"image",
					`./temp/stickers/${sender}`
				);
				const fd = new FormData();
				const imgbbUploader = require("imgbb-uploader");
				fd.append("file", fs.readFileSync(media), ".tmp", ".jpg");
				await imgbbUploader(
					"0d434733a8620f34c2183b09af2b135d",
					`./temp/stickers/${sender}`
				).then((data) => {
					updateResponList(
						from,
						_args1,
						_args2,
						true,
						`${data.display_url}`,
						db_respon_list
					);
					reply(`Sukses Updatelist : *${_args1}*`);
					if (fs.existsSync(media)) fs.unlinkSync(media);
				});
			} else {
				updateResponList(from, _args1, _args2, false, "-", db_respon_list);
				reply(`Sukses Updatelist : *${_args1}*`);
			}
			break;
		case "jeda":
			{
				if (isPricelist)
					return reply(
						`Fitur Pricelist Disable Untuk Melihat Fitur Ketik ${prefix}help`
					);
				if (!isGroup) return replyDeface(mess.OnlyGrup);
				if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
				if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
				if (!args[0])
					return replyDeface(
						`kirim ${command} waktu\nContoh: ${command} 30m\n\nlist waktu:\ns = detik\nm = menit\nh = jam\nd = hari`
					);
				opengc[from] = { id: from, time: Date.now() + toMS(args[0]) };
				fs.writeFileSync("./database/opengc.json", JSON.stringify(opengc));
				setya
					.groupSettingUpdate(from, "announcement")
					.then((res) =>
						replyDeface(`Jeda Dulu Ya Group Akan Di Buka Dalam ${args[0]} Lagi`)
					)
					.catch((err) => replyDeface("Error"));
			}
			break;
		case "kalkulator":
		case "hitung":
		case "total":
		case "hasil":
			if (!isGroup) return reply(`Bot Hanya Respon Di Dalam Group`);
			if (!q)
				return reply(
					`( + ) = Untuk Tambah-Tambahan\n( - ) = Untuk Kurang-Kurangan\n( * ) = Untuk Kali-Kalian\n( / ) = Untuk Bagi-Bagian\n\nContoh\n/kalkulator 40+20`
				);
			var tteks = `Hasil : ${Math_js.evaluate(q)}`;
			replyDeface(tteks);
			break;
		case "p":
		case "proses":
			if (!isGroup) return;
			if (!isOwner && !isGroupAdmins) return;
			let proses = `O━• *Transaksi Proses* •━O

${gy}🎉 Status : Pending
🎊 Mohon Di Tunggu
📆 ${tanggal}
⏰ ${jam}${gy}

✎📜 Pesanan : 
${rm.quoted.text}

📜 *Pesanan @${rm.quoted.sender.split("@")[0]} Pending Mohon Di Tunggu*
━O━O━••••••••••••━O━O━`;
			const getTextP = getTextSetProses(from, set_proses);
			if (getTextP !== undefined) {
				mentions(
					getTextP
						.replace("@pesanan", rm.quoted.text)
						.replace("user", rm.quoted.sender.split("@")[0])
						.replace("@jam", jam)
						.replace("@tanggal", tanggal),
					[rm.quoted.sender],
					true
				);
			} else {
				mentions(proses, [rm.quoted.sender], true);
			}
			break;

		case "d":
		case "done":
			if (!isGroup) return;
			if (!isOwner && !isGroupAdmins) return;
			let sukses = `O━• *Transaksi Sukses* •━O

${gy}🎉 Status : Sukses
📆 ${tanggal}
⏰ ${jam}${gy}

✎📜 Pesanan : 
${msg.quoted.text}

📜 *Pesanan @${msg.sender.split("@")[0]} Sukses*
━O━O━••••••••••••━O━O━`;
			const getTextD = getTextSetDone(from, set_done);
			if (getTextD !== undefined) {
				mentions(
					getTextD
						.replace("@pesanan", rm.quoted.text)
						.replace("user", msg.sender.split("@")[0])
						.replace("@jam", jam)
						.replace("@tanggal", tanggal),
					[msg.sender],
					true
				);
			} else {
				mentions(sukses, [msg.sender], true);
			}
			break;
		case "setproses":
		case "setp":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`*Ini Hanya Contoh*\n${prefix}setp Pesanan Proses\n@jam\n@tanggal\nPesanan : @pesanan\n\nPesanan @user Sedang Di Proses `
				);
			if (isSetProses(from, set_proses))
				return replyDeface(`Sudah Ada Setp Sebelumnya`);
			//addCountCmd(`${prefix}setproses`, sender, _cmd)
			addSetProses(q, from, set_proses);
			replyDeface(`Sukses Set Proses!`);
			break;
		case "changeproses":
		case "updatep":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`*Ini Hanya Contoh*\n${prefix}updatep Pesanan Proses\n@jam\n@tanggal\nPesanan : @pesanan\n\nPesanan @user Sedang Di Proses`
				);
			//addCountCmd(`${prefix}changeproses`, sender, _cmd)
			if (isSetProses(from, set_proses)) {
				changeSetProses(q, from, set_proses);
				replyDeface(`Sukses Update Set Proses`);
			} else {
				addSetProses(q, from, set_proses);
				replyDeface(`Sukses Update Set Proses`);
			}
			break;
		case "delsetproses":
		case "delsetp":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isSetProses(from, set_proses))
				return replyDeface(`Belum ada set proses di sini..`);
			//addCountCmd(`${prefix}delsetproses`, sender, _cmd)
			removeSetProses(from, set_proses);
			replyDeface(`Sukses Delete Set Proses`);
			break;
		case "setdone":
		case "setd":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`*Ini Hanya Contoh*\n${prefix}setd Pesanan Sukses\n@jam\n@tanggal\nPesanan : @pesanan\n\nPesanan @user Sukses`
				);
			if (isSetDone(from, set_done))
				return replyDeface(`Sudah Ada Setd Sebelumnya`);
			//addCountCmd(`${prefix}setdone`, sender, _cmd)
			addSetDone(q, from, set_done);
			replyDeface(`Sukses Setd!`);
			break;
		case "changedone":
		case "updated":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`*Ini Hanya Contoh*\n${prefix}updated Pesanan Sukses\n@jam\n@tanggal\nPesanan : @pesanan\n\nPesanan @user Sukses`
				);
			//addCountCmd(`${prefix}changedone`, sender, _cmd)
			if (isSetDone(from, set_done)) {
				changeSetDone(q, from, set_done);
				replyDeface(`Sukses Update Setd`);
			} else {
				addSetDone(q, from, set_done);
				replyDeface(`Sukses Update Setd`);
			}
			break;
		case "delsetdone":
		case "delsetd":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isSetDone(from, set_done))
				return replyDeface(`Belum ada set done di sini..`);
			//addCountCmd(`${prefix}delsetdone`, sender, _cmd)
			removeSetDone(from, set_done);
			replyDeface(`Sukses Delete Setd`);
			break;
		//SETBOT
		case "setbot":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`*Ini Hanya Contoh*\n${prefix}setbot Halo Silahkan Ketik #menu Untuk Melihat List Di Group Ini`
				);
			if (isSetBot(from, set_bot))
				return replyDeface(`Sudah Ada Setbot Sebelumnya`);
			//addCountCmd(`${prefix}setbot`, sender, _cmd)
			addSetBot(q, from, set_bot);
			replyDeface(`Sukses Respon Bot!`);
			break;
		case "changebot":
		case "updatesetbot":
		case "upsetbot":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`*Ini Hanya Contoh*\n${prefix}updatesetbot Hai Kak Silahkan Ketik #menu Untuk Melihat List`
				);
			//addCountCmd(`${prefix}changebot`, sender, _cmd)
			if (isSetBot(from, set_bot)) {
				changeSetBot(q, from, set_bot);
				replyDeface(`Sukses Update Respon Bot`);
			} else {
				addSetBot(q, from, set_bot);
				replyDeface(`Sukses Update Respon Bot`);
			}
			break;
		case "delsetbot":
		case "delsetb":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isSetBot(from, set_bot))
				return replyDeface(`Belum ada setbot di sini..`);
			//addCountCmd(`${prefix}delsetbot`, sender, _cmd)
			removeSetBot(from, set_bot);
			replyDeface(`Sukses Delete Respon Bot`);
			break;
		case "add":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins) return replyDeface(mess.GrupAdmin);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			if (groupMembers.length == 257)
				return reply(
					`Anda tidak dapat menambah peserta, karena Grup sudah penuh!`
				);
			var mems = [];
			groupMembers.map((i) => mems.push(i.id));
			var number;
			if (args.length > 0) {
				number = q.replace(/[^0-9]/gi, "") + "@s.whatsapp.net";
				var cek = await setya.onWhatsApp(number);
				if (cek.length == 0)
					return reply(`Masukkan nomer yang valid dan terdaftar di WhatsApp`);
				if (mems.includes(number))
					return reply(`Nomer tersebut sudah berada didalam grup!`);
				////addCountCmd(`${prefix}add`, sender, _cmd)
				setya
					.groupParticipantsUpdate(from, [number], "add")
					.then((res) => reply(jsonformat(res)))
					.catch((err) => reply(jsonformat(err)));
			} else if (m.isQuotedMsg) {
				number = m.quotedMsg.sender;
				var cek = await setya.onWhatsApp(number);
				if (cek.length == 0)
					return reply(`Peserta tersebut sudah tidak terdaftar di WhatsApp`);
				if (mems.includes(number))
					return reply(`Nomer tersebut sudah berada didalam grup!`);
				////addCountCmd(`${prefix}add`, sender, _cmd)
				setya
					.groupParticipantsUpdate(from, [number], "add")
					.then((res) => reply(jsonformat(res)))
					.catch((err) => reply(jsonformat(err)));
			} else {
				reply(
					`Kirim perintah ${command} nomer atau balas pesan orang yang ingin dimasukkan`
				);
			}
			break;
		case "kick":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins) return replyDeface(mess.GrupAdmin);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			var number;
			if (mentionUser.length !== 0) {
				number = mentionUser[0];
				////addCountCmd(`${prefix}kick`, sender, _cmd)
				setya
					.groupParticipantsUpdate(from, [number], "remove")
					.then((res) => replyDeface(jsonformat(res)))
					.catch((err) => replyDeface(jsonformat(err)));
			} else if (isQuotedMsg) {
				number = m.quotedMsg.sender;
				////addCountCmd(`${prefix}kick`, sender, _cmd)
				setya
					.groupParticipantsUpdate(from, [number], "remove")
					.then((res) => replyDeface(jsonformat(res)))
					.catch((err) => replyDeface(jsonformat(err)));
			} else {
				replyDeface(
					`Tag atau balas pesan orang yang ingin dikeluarkan dari grup`
				);
			}
			break;
		case "promote":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins) return replyDeface(mess.GrupAdmin);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			if (mentionUser.length !== 0) {
				////addCountCmd(`${prefix}promote`, sender, _cmd)
				setya
					.groupParticipantsUpdate(from, [mentionUser[0]], "promote")
					.then((res) => {
						mentions(
							`Sukses menjadikan @${
								mentionUser[0].split("@")[0]
							} sebagai admin`,
							[mentionUser[0]],
							true
						);
					})
					.catch(() => replyDeface(mess.error.api));
			} else if (m.isQuotedMsg) {
				////addCountCmd(`${prefix}promote`, sender, _cmd)
				setya
					.groupParticipantsUpdate(from, [m.quotedMsg.sender], "promote")
					.then((res) => {
						mentions(
							`Sukses menjadikan @${
								m.quotedMsg.sender.split("@")[0]
							} sebagai admin`,
							[m.quotedMsg.sender],
							true
						);
					})
					.catch(() => replyDeface(mess.error.api));
			} else {
				replyDeface(`Tag atau balas pesan member yang ingin dijadikan admin`);
			}
			break;
		case "demote":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins) return replyDeface(mess.GrupAdmin);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			if (mentionUser.length !== 0) {
				////addCountCmd(`${prefix}demote`, sender, _cmd)
				setya
					.groupParticipantsUpdate(from, [mentionUser[0]], "demote")
					.then((res) => {
						mentions(
							`Sukses menjadikan @${
								mentionUser[0].split("@")[0]
							} sebagai member biasa`,
							[mentionUser[0]],
							true
						);
					})
					.catch(() => replyDeface(mess.error.api));
			} else if (m.isQuotedMsg) {
				////addCountCmd(`${prefix}demote`, sender, _cmd)
				setya
					.groupParticipantsUpdate(from, [m.quotedMsg.sender], "demote")
					.then((res) => {
						mentions(
							`Sukses menjadikan @${
								m.quotedMsg.sender.split("@")[0]
							} sebagai member biasa`,
							[m.quotedMsg.sender],
							true
						);
					})
					.catch(() => replyDeface(mess.error.api));
			} else {
				replyDeface(
					`Tag atau balas pesan admin yang ingin dijadikan member biasa`
				);
			}
			break;

		case "owner":
		case "sewabot":
			sendContact(from, ownnumber.split("@s.whatsapp.net")[0], ownerName, msg)
				// setya.sendContact(from, ownerNumber.map( i => i.split("@")[0]), msg)
				.then((res) =>
					setya.sendMessage(
						from,
						{ text: "*Jika Ingin Sewabot Silahkan Hubungi Owner Ku*" },
						{ quoted: res }
					)
				);
			break;

		case "getlink":
			if (!isOwner) return reply(`Command ${command} Hanya Khusus Owner`);
			if (!q) return reply("*Sertai Id Group*");
			var linkgc = await setya.groupInviteCode(`${q}`);
			reply("https://chat.whatsapp.com/" + linkgc);
			break;

		case "addsewa":
			if (!isOwner) return;
			if (args.length < 1) return;
			if (!isUrl(args[0])) return replyDeface(mess.error.Iv);
			var url = args[0];
			url = url.split("https://chat.whatsapp.com/")[1];
			if (!args[1]) return replyDeface(`Waktunya?`);
			var data = await setya.groupAcceptInvite(url);
			if (_sewa.checkSewaGroup(data, sewa))
				return replyDeface(`Bot sudah disewa oleh grup tersebut!`);
			_sewa.addSewaGroup(data, args[1], sewa);
			replyDeface(`Success Add Sewa Group!`);
			break;

		case "addsw":
		case "sewarpl":
		case "perpanjang":
			if (!isOwner) return reply(`Command ${command} Hanya Khusus Owner`);
			if (args.length < 1)
				return reply(
					`Penggunaan :\n*${prefix}addsewa 15k 30d*/n*Ini Hanya Contoh*`
				);
			_sewa.addSewaGroup(from, args[1], sewa);
			reply(`Success Add Sewa`);
			break;

		case "delsewa":
			if (!isOwner) return replyDeface(mess.OnlyOwner);
			if (!isGroup)
				return replyDeface(
					`Perintah ini hanya bisa dilakukan di Grup yang menyewa bot`
				);
			if (!isSewa) return replyDeface(`Bot tidak disewa di Grup ini`);
			sewa.splice(_sewa.getSewaPosition(from, sewa), 1);
			fs.writeFileSync("./database/sewa.json", JSON.stringify(sewa));
			replyDeface(`Sukses`);
			break;

		case "delsw":
			if (!isOwner) return replyDeface(mess.OnlyOwner);
			if (!isGroup)
				return replyDeface(
					`Perintah ini hanya bisa dilakukan di Grup yang menyewa bot`
				);
			if (!isSewa) return replyDeface(`Bot tidak disewa di Grup ini`);
			sewa.splice(_sewa.getSewaPosition(args[0], sewa), 1);
			fs.writeFileSync("./database/sewa.json", JSON.stringify(sewa, null, 2));
			replyDeface(`Sukses`);
			break;

		case "checksewa":
		case "ceksewa":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isSewa) return replyDeface(`Bot tidak di sewa group ini!`);
			let ceksewa = ms(_sewa.getSewaExpired(from, sewa) - Date.now());
			let sewanya = `*Expire :* ${ceksewa.days} day(s) ${ceksewa.hours} hour(s) ${ceksewa.minutes} minute(s)`;
			replyDeface(sewanya);
			break;

		case "listsewa":
			if (!isOwner) return replyDeface(mess.OnlyOwner);
			let list_sewa_list = `*LIST-SEWA-GROUP*\n\n*Total:* ${sewa.length}\n\n`;
			let data_array = [];
			for (let x of sewa) {
				////addCountCmd(`${prefix}listsewa`, sender, _cmd)
				list_sewa_list += `*Name:* ${await getGcName(x.id)}\n*ID :* ${x.id}\n`;
				if (x.expired === "PERMANENT") {
					let ceksewa = "PERMANENT";
					list_sewa_list += `*Expire :* PERMANENT\n\n`;
				} else {
					let ceksewa = ms(x.expired - Date.now());
					list_sewa_list += `*Expire :* ${ceksewa.days} day(s) ${ceksewa.hours} hour(s) ${ceksewa.minutes} minute(s) ${ceksewa.seconds} second(s)\n\n`;
				}
			}
			setya.sendMessage(from, { text: list_sewa_list }, { quoted: msg });
			break;

		case "setppgrup":
		case "setppgc":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			if (isImage || isQuotedImage) {
				//addCountCmd(`${prefix}setppgrup`, sender, _cmd)
				var media = await downloadAndSaveMediaMessage(
					"image",
					`ppgc${from}.jpeg`
				);
				if (args[0] == "'panjang'") {
					var { img } = await generateProfilePicture(media);
					await setya.query({
						tag: "iq",
						attrs: {
							to: from,
							type: "set",
							xmlns: "w:profile:picture",
						},
						content: [
							{
								tag: "picture",
								attrs: { type: "image" },
								content: img,
							},
						],
					});
					fs.unlinkSync(media);
					replyDeface(`Sukses`);
				} else {
					await setya
						.updateProfilePicture(from, { url: media })
						.then((res) => {
							replyDeface(`Sukses`);
							fs.unlinkSync(media);
						})
						.catch(() => replyDeface(mess.error.api));
				}
			} else {
				replyDeface(`Kirim/balas gambar dengan caption ${command}`);
			}
			break;
		case "setnamegrup":
		case "setnamegc":
		case "setname":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			if (args.length < 0)
				return replyDeface(
					`Gunakan dengan cara ${command} *text*\n\n_Contoh_\n\n${command} Support ${ownerName}`
				);
			//addCountCmd(`${prefix}setnamegc`, sender, _cmd)
			await setya
				.groupUpdateSubject(from, q)
				.then((res) => {
					replyDeface(`Sukses`);
				})
				.catch(() => replyDeface(mess.error.api));
			break;
		case "setdesc":
		case "setdescription":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			if (args.length < 0)
				return replyDeface(
					`Gunakan dengan cara ${command} *text*\n\n_Contoh_\n\n${command} New Description by ${ownerName}`
				);
			//addCountCmd(`${prefix}setdesc`, sender, _cmd)
			await setya
				.groupUpdateDescription(from, q)
				.then((res) => {
					replyDeface(`Sukses`);
				})
				.catch(() => replyDeface(mess.error.api));
			break;

		case "revoke":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins) return replyDeface(mess.GrupAdmin);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			await setya
				.groupRevokeInvite(from)
				.then((res) => {
					replyDeface(`Sukses menyetel tautan undangan grup ini`);
				})
				.catch(() => replyDeface(mess.error.api));
			break;
		case "hidetag":
		case "h":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			let mem = [];
			groupMembers.map((i) => mem.push(i.id));
			setya.sendMessage(from, {
				text: q ? q : "_HIDE TAG_",
				mentions: mem,
			});
			break;
		case "tagall":
			{
				if (!isGroup) return replyDeface(mess.OnlyGrup);
				if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
				let teks = `      〘 *👥 Tag All* 〙
 
 ➲ *Pesan : ${q ? q : "Order Oy Order"}*\n\n`;
				for (let mem of participants) {
					teks += `⭔ @${mem.id.split("@")[0]}\n`;
				}
				setya.sendMessage(
					from,
					{ text: teks, mentions: participants.map((a) => a.id) },
					{ quoted: m }
				);
			}
			break;
		case "delete":
		case "del":
		case "d":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!m.isQuotedMsg)
				return replyDeface(`Balas chat dari bot yang ingin dihapus`);
			if (!m.quotedMsg.fromMe)
				return replyDeface(`Hanya bisa menghapus chat dari bot`);
			setya.sendMessage(from, {
				delete: { fromMe: true, id: m.quotedMsg.id, remoteJid: from },
			});
			break;

		case "welcome":
			if (!isGroup) return reply(`Bot Hanya Respon Di Dalam Group`);
			if (!isOwner && !isGroupAdmins)
				return reply(`Command ${command} Hanya Khusus Admin`);
			if (!isBotGroupAdmins)
				return reply(`*Jadi Kan Bot Admin Sebelum Menggunakan*`);
			if (args.length < 1)
				return reply(
					`Untuk Mengaktifkan Ketik 1\nContoh : ${prefix}welcome 1\n\nUntuk Nonaktifkan Welcome Ketik 0\nContoh : ${prefix}welcome 0`
				);
			if (Number(args[0]) === 1) {
				if (isWelcome) return reply("welcome sudah aktif");
				welcome.push(from);
				fs.writeFileSync("./database/welcome.json", JSON.stringify(welcome));
				reply("Done Mengaktifkan welcome✅");
				setya.sendMessage(from, { text: `*Welcome Online*` });
			} else if (Number(args[0]) === 0) {
				if (!isWelcome) return reply("Mode welcome sudah disable");
				let anu1 = antiwame.indexOf(from);
				welcome.splice(anu1, 1);
				fs.writeFileSync("./database/welcome.json", JSON.stringify(welcome));
				reply("Sukes menonaktifkan welcome di group ini ✔️");
			} else {
				reply("1 untuk mengaktifkan, 0 untuk menonaktifkan");
			}
			break;
		case "leave":
		case "left":
			if (!isGroup) return reply(`Bot Hanya Respon Di Dalam Group`);
			if (!isOwner && !isGroupAdmins)
				return reply(`Command ${command} Hanya Khusus Admin`);
			if (!isBotGroupAdmins)
				return reply(`*Jadi Kan Bot Admin Sebelum Menggunakan*`);
			if (args.length < 1)
				return reply(
					`Untuk Mengaktifkan Ketik 1\nContoh : ${prefix}leave 1\n\nUntuk Nonaktifkan Leave Ketik 0\nContoh : ${prefix}leave 0`
				);
			if (Number(args[0]) === 1) {
				if (isLeft) return reply("left sudah aktif");
				left.push(from);
				fs.writeFileSync("./database/left.json", JSON.stringify(left));
				reply("Done Mengaktifkan left✅");
				setya.sendMessage(from, { text: `*Left Online*` });
			} else if (Number(args[0]) === 0) {
				if (!isLeft) return reply("Mode left sudah disable");
				let anu1 = antiwame.indexOf(from);
				left.splice(anu1, 1);
				fs.writeFileSync("./database/left.json", JSON.stringify(left));
				reply("Sukes menonaktifkan left di group ini ✔️");
			} else {
				reply("1 untuk mengaktifkan, 0 untuk menonaktifkan");
			}
			break;

		case "price":
			if (!isGroup) return reply(`Bot Hanya Respon Di Dalam Group`);
			if (!isOwner) return reply(`Command ${command} Hanya Khusus Admin`);
			if (args.length < 1)
				return reply(
					`Untuk Mengaktifkan Ketik 1\nContoh : ${prefix}price 0\n\nUntuk Nonaktifkan Pricelist Ketik 1\nContoh : ${prefix}pricelist 1`
				);
			if (Number(args[0]) === 0) {
				if (isPricelist) return reply("Pricelist sudah aktif");
				pricelist.push(from);
				fs.writeFileSync(
					"./database/pricelist.json",
					JSON.stringify(pricelist)
				);
				reply("Done Mengaktifkan Pricelist Group✅");
				setya.sendMessage(from, { text: `Done Mengaktifkan Pricelist Group` });
			} else if (Number(args[0]) === 1) {
				if (!isPricelist) return reply("Pricelist sudah disable");
				let anu1 = pricelist.indexOf(from);
				pricelist.splice(anu1, 1);
				fs.writeFileSync(
					"./database/pricelist.json",
					JSON.stringify(pricelist)
				);
				reply("Sukes menonaktifkan Pricelist group di group ini ✔️");
			} else {
				reply("1 untuk mengaktifkan, 0 untuk menonaktifkan");
			}
			break;

		case "antilink":
			if (!isGroup) return reply(`Bot Hanya Respon Di Dalam Group`);
			if (!isOwner && !isGroupAdmins)
				return reply(`Command ${command} Hanya Khusus Admin`);
			if (!isBotGroupAdmins)
				return reply(`*Jadi Kan Bot Admin Sebelum Menggunakan Fitur Antilink*`);
			if (args.length < 1)
				return reply(
					`Untuk Mengaktifkan Ketik 1\nContoh : ${prefix}antilink 1\n\nUntuk Nonaktifkan Antilink Ketik 0\nContoh : ${prefix}antilink 0`
				);
			if (Number(args[0]) === 1) {
				if (isAntiLink) return reply("anti link group sudah aktif");
				antilink.push(from);
				fs.writeFileSync("./database/antilink.json", JSON.stringify(antilink));
				reply("Done Mengaktifkan Antilink Group✅");
				setya.sendMessage(from, {
					text: `Perhatian kepada seluruh member anti link group aktif apabila anda mengirim link group anda akan di kick dari group`,
				});
			} else if (Number(args[0]) === 0) {
				if (!isAntiLink) return reply("Mode anti link group sudah disable");
				let anu1 = antilink.indexOf(from);
				antilink.splice(anu1, 1);
				fs.writeFileSync("./database/antilink.json", JSON.stringify(antilink));
				reply("Sukes menonaktifkan anti link group di group ini ✔️");
			} else {
				reply("1 untuk mengaktifkan, 0 untuk menonaktifkan");
			}
			break;

		case "antilinkall":
			if (!isGroup) return reply(`Bot Hanya Respon Di Dalam Group`);
			if (!isOwner && !isGroupAdmins)
				return reply(`Command ${command} Hanya Khusus Admin`);
			if (!isBotGroupAdmins)
				return reply(`*Jadi Kan Bot Admin Sebelum Menggunakan Fitur Antilink*`);
			if (args.length < 1)
				return reply(
					`Untuk Mengaktifkan Ketik 1\nContoh : ${prefix}antilink 1\n\nUntuk Nonaktifkan Antilink Ketik 0\nContoh : ${prefix}antilink 0`
				);
			if (Number(args[0]) === 1) {
				if (isAntiLinkAll) return reply("anti link all group sudah aktif");
				antilinkall.push(from);
				fs.writeFileSync(
					"./database/antilinkall.json",
					JSON.stringify(antilinkall)
				);
				reply("Done Mengaktifkan Antilink all Group✅");
				setya.sendMessage(from, {
					text: `Perhatian kepada seluruh member anti link group aktif apabila anda mengirim link group anda akan di kick dari group`,
				});
			} else if (Number(args[0]) === 0) {
				if (!isAntiLinkAll)
					return reply("Mode anti link all group sudah disable");
				let anu1 = antilinkall.indexOf(from);
				antilinkall.splice(anu1, 1);
				fs.writeFileSync(
					"./database/antilinkall.json",
					JSON.stringify(antilinkall)
				);
				reply("Sukes menonaktifkan anti link all group di group ini ✔️");
			} else {
				reply("1 untuk mengaktifkan, 0 untuk menonaktifkan");
			}
			break;

		case "antilinkwame":
			if (!isGroup) return reply(`Bot Hanya Respon Di Dalam Group`);
			if (!isOwner && !isGroupAdmins)
				return reply(`Command ${command} Hanya Khusus Admin`);
			if (!isBotGroupAdmins)
				return reply(`*Jadi Kan Bot Admin Sebelum Menggunakan Fitur Antilink*`);
			if (args.length < 1)
				return reply(
					`Untuk Mengaktifkan Ketik 1\nContoh : ${prefix}antiwame 1\n\nUntuk Nonaktifkan Antiwame Ketik 0\nContoh : ${prefix}antiwame 0`
				);
			if (Number(args[0]) === 1) {
				if (isAntiWame) return reply("antiwame group sudah aktif");
				antiwame.push(from);
				fs.writeFileSync("./database/antiwame.json", JSON.stringify(antiwame));
				reply("Done Mengaktifkan antiwame Group✅");
				setya.sendMessage(from, {
					text: `Perhatian kepada seluruh member antiwame aktif apabila anda mengirim link antiwame anda akan di kick dari group`,
				});
			} else if (Number(args[0]) === 0) {
				if (!isAntiWame) return reply("Mode antiwame group sudah disable");
				let anu1 = antiwame.indexOf(from);
				antiwame.splice(anu1, 1);
				fs.writeFileSync("./database/antiwame.json", JSON.stringify(antiwame));
				reply("Sukes menonaktifkan antiwame group di group ini ✔️");
			} else {
				reply("1 untuk mengaktifkan, 0 untuk menonaktifkan");
			}
			break;

		case "down":
			if (!isGroup) return reply(`Bot Hanya Respon Di Dalam Group`);
			if (!isOwner && !isGroupAdmins)
				return reply(`Command ${command} Hanya Khusus Admin`);
			if (args.length < 1)
				return reply(
					`Untuk Mengaktifkan Ketik 1\nContoh : ${prefix}down 1\n\nUntuk Nonaktifkan Ketik 0\nContoh : ${prefix}down 0`
				);
			if (Number(args[0]) === 1) {
				if (isDownload) return reply("Fitur Download sudah aktif");
				downloadfitur.push(from);
				fs.writeFileSync(
					"./database/download.json",
					JSON.stringify(downloadfitur)
				);
				reply("Sukses Mengaktifkan All Fitur Download Di Group Ini");
				setya.sendMessage(from, {
					text: `Sukses Mengaktifkan All Fitur Download Di Group Ini`,
				});
			} else if (Number(args[0]) === 0) {
				if (!isDownload) return reply("Fitur Download sudah disable");
				let anu1 = downloadfitur.indexOf(from);
				downloadfitur.splice(anu1, 1);
				fs.writeFileSync(
					"./database/download.json",
					JSON.stringify(downloadfitur)
				);
				reply("Sukses Menonaktifkan All Fitur Download Di Group Ini");
			} else {
				reply("1 untuk mengaktifkan, 0 untuk menonaktifkan");
			}
			break;

		case "open":
		case "buka":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			setya.groupSettingUpdate(from, "not_announcement").then((res) => {
				let opengc = `O━• *Group Open* •━O

📜 *Group Telah Di Buka Oleh Admin* @${sender.split("@")[0]}

${gaya}🎊 Group Open
📆 ${tanggal}
⏰ ${jam}${gaya}

━O━O━••••••••••••━O━O━`;
				const tettOpen = getTextSetOpen(from, set_open);
				if (tettOpen !== undefined) {
					mentions(
						tettOpen
							.replace("admin", sender.split("@")[0])
							.replace("@jam", jam)
							.replace("@tanggal", tanggal),
						[sender],
						true
					);
				} else {
					mentions(opengc, [sender], true);
				}
			});
			break;

		case "close":
		case "tutup":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			setya
				.groupSettingUpdate(from, "announcement")
				.then((res) => {
					let closegc = `O━• *Group Close* •━O

📜 *Group Telah Di Tutup Oleh Admin* @${sender.split("@")[0]}

${gaya}🎊 Group Tutup
📆 ${tanggal}
⏰ ${jam}${gaya}

━O━O━••••••••••••━O━O━`;
					const textClose = getTextSetClose(from, set_close);
					if (textClose !== undefined) {
						mentions(
							textClose
								.replace("admin", sender.split("@")[0])
								.replace("@jam", jam)
								.replace("@tanggal", tanggal),
							[sender],
							true
						);
					} else {
						mentions(closegc, [sender], true);
					}
				})
				.catch((err) => replyDeface("Error"));
			break;

		case "setopen":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`Gunakan dengan cara ${command} *teks_open*\n\n_Contoh_\n\n${command} Group telah di buka`
				);
			if (isSetOpen(from, set_open))
				return replyDeface(`Set Open already active`);
			addSetOpen(q, from, set_open);
			replyDeface(`Successfully set Open!`);
			break;
		case "updateopen":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`Gunakan dengan cara ${command} *teks_open*\n\n_Contoh_\n\n${command} Group telah di buka`
				);
			if (isSetOpen(from, set_open)) {
				changeSetOpen(q, from, set_open);
				replyDeface(`Sukses change set Open teks!`);
			} else {
				addSetOpen(q, from, set_open);
				replyDeface(`Sukses change set Open teks!`);
			}
			break;
		case "delsetopen":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isSetOpen(from, set_open))
				return replyDeface(`Belum ada set Open di sini..`);
			removeSetOpen(from, set_open);
			replyDeface(`Sukses delete set Open`);
			break;
		case "setclose":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`Gunakan dengan cara ${command} *teks_close*\n\n_Contoh_\n\n${command} Group telah di tutup`
				);
			if (isSetClose(from, set_close))
				return replyDeface(`Set Close already active`);
			addSetClose(q, from, set_close);
			replyDeface(`Successfully set Close!`);
			break;
		case "updateclose":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`Gunakan dengan cara ${command} *teks_close*\n\n_Contoh_\n\n${command} Group telah di tutup`
				);
			if (isSetClose(from, set_close)) {
				changeSetClose(q, from, set_close);
				replyDeface(`Sukses change set Close teks!`);
			} else {
				addSetClose(q, from, set_close);
				replyDeface(`Sukses change set Close teks!`);
			}
			break;
		case "delsetclose":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isSetClose(from, set_close))
				return replyDeface(`Belum ada set Close di sini..`);
			removeSetClose(from, set_close);
			replyDeface(`Sukses delete set Close`);
			break;

		case "setwelcome":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`Gunakan dengan cara ${command} *teks_welcome*\n\n_Contoh_\n\n${command} Halo @nama, Selamat datang di @grup`
				);
			if (isSetWelcome(from, set_welcome_db))
				return replyDeface(`Sudah Ada Setwelcone Sebelumnya`);
			addSetWelcome(q, from, set_welcome_db);
			replyDeface(`Sukses Setwelcome!`);
			break;
		case "updatewelcome":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`Gunakan dengan cara ${command} *teks_welcome*\n\n_Contoh_\n\n${command} Halo @nama, Selamat datang di @grup`
				);
			if (isSetWelcome(from, set_welcome_db)) {
				//addCountCmd(`${prefix}changewelcome`, sender, _cmd)
				changeSetWelcome(q, from, set_welcome_db);
				replyDeface(`Sukses change set welcome teks!`);
			} else {
				//addCountCmd(`${prefix}changewelcome`, sender, _cmd)
				addSetWelcome(q, from, set_welcome_db);
				replyDeface(`Sukses Update Setwelcome`);
			}
			break;
		case "delwelcome":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isSetWelcome(from, set_welcome_db))
				return replyDeface(`Belum Ada Setwelcone Sebelumnya`);
			removeSetWelcome(from, set_welcome_db);
			//addCountCmd(`${prefix}delsetwelcome`, sender, _cmd)
			replyDeface(`Sukses Delete Setwelcome`);
			break;
		case "setleave":
		case "setleft":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`Gunakan dengan cara ${command} *teks_left*\n\n_Contoh_\n\n${command} Halo @nama, Selamat tinggal dari @grup`
				);
			if (isSetLeft(from, set_left_db))
				return replyDeface(`Sudah Ada Setleave Sebelumnya`);
			//addCountCmd(`${prefix}setleft`, sender, _cmd)
			addSetLeft(q, from, set_left_db);
			replyDeface(`Sukses Setleave`);
			break;
		case "updateleave":
		case "updateleft":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!q)
				return replyDeface(
					`Gunakan dengan cara ${command} *teks_left*\n\n_Contoh_\n\n${command} Halo @nama, Selamat tinggal dari @grup`
				);
			if (isSetLeft(from, set_left_db)) {
				//addCountCmd(`${prefix}updateleft`, sender, _cmd)
				changeSetLeft(q, from, set_left_db);
				replyDeface(`Sukses Update Setleave`);
			} else {
				//addCountCmd(`${prefix}updateleft`, sender, _cmd)
				addSetLeft(q, from, set_left_db);
				replyDeface(`Sukses Update Setleave`);
			}
			break;
		case "delsetleft":
		case "delleave":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isGroupAdmins && !isOwner) return replyDeface(mess.GrupAdmin);
			if (!isSetLeft(from, set_left_db))
				return replyDeface(`Belum Ada SetLeave Sebelumnya`);
			//addCountCmd(`${prefix}delsetleft`, sender, _cmd)
			removeSetLeft(from, set_left_db);
			replyDeface(`Sukses Delete Setleave`);
			break;
		case "linkgrup":
		case "link":
		case "linkgc":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isBotGroupAdmins) return replyDeface(mess.BotAdmin);
			var url = await setya
				.groupInviteCode(from)
				.catch(() => replyDeface(mess.error.api));
			url = "https://chat.whatsapp.com/" + url;
			replyDeface(url);
			break;
		case "toimg":
		case "toimage":
		case "tovid":
		case "tovideo":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			//if (isLimit(sender, isPremium, isOwner, limitCount, limit)) return replyDeface(`Limit kamu sudah habis silahkan kirim ${prefix}limit untuk mengecek limit`)
			if (!isQuotedSticker) return replyDeface(`Reply stikernya!`);
			var stream = await downloadContentFromMessage(
				msg.message.extendedTextMessage?.contextInfo.quotedMessage
					.stickerMessage,
				"sticker"
			);
			var buffer = Buffer.from([]);
			for await (const chunk of stream) {
				buffer = Buffer.concat([buffer, chunk]);
			}
			var rand1 = "temp/" + getRandom(".webp");
			var rand2 = "temp/" + getRandom(".png");
			fs.writeFileSync(`./${rand1}`, buffer);
			if (
				isQuotedSticker &&
				msg.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage
					.isAnimated !== true
			) {
				//addCountCmd(`${prefix}toimg`, sender, _cmd)
				exec(`ffmpeg -i ./${rand1} ./${rand2}`, (err) => {
					fs.unlinkSync(`./${rand1}`);
					if (err) return replyDeface(mess.error.api);
					setya.sendMessage(
						from,
						{ image: fs.readFileSync(`./${rand2}`) },
						{ quoted: msg }
					);
					//limitAdd(sender, limit)
					fs.unlinkSync(`./${rand2}`);
				});
			} else {
				replyDeface(mess.wait);
				//addCountCmd(`${prefix}tovid`, sender, _cmd)
				webp2mp4File(`./${rand1}`).then(async (data) => {
					fs.unlinkSync(`./${rand1}`);
					setya.sendMessage(
						from,
						{ video: await getBuffer(data.data) },
						{ quoted: msg }
					);
					//limitAdd(sender, limit)
				});
			}
			break;
		case "tomp3":
		case "toaudio":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			//if (isLimit(sender, isPremium, isOwner, limitCount, limit)) return replyDeface(`Limit kamu sudah habis silahkan kirim ${prefix}limit untuk mengecek limit`)
			if (isVideo || isQuotedVideo) {
				let media = await downloadAndSaveMediaMessage(
					"video",
					`./temp/${sender}.mp4`
				);
				replyDeface(mess.wait);
				//addCountCmd(`${prefix}tomp3`, sender, _cmd)
				let ran = "./temp/" + getRandom(".mp3");
				exec(`ffmpeg -i ${media} ${ran}`, async (err) => {
					fs.unlinkSync(media);
					if (err) return replyDeface("Gagal :V");
					setya.sendMessage(
						from,
						{
							audio: fs.readFileSync(ran),
							mimetype: "audio/mp4",
							fileName: `${sender.split("@")[0]}ToMp3`,
						},
						{ quoted: msg }
					);
					//limitAdd(sender, limit)
					fs.unlinkSync(media);
					fs.unlinkSync(ran);
				});
			} else {
				replyDeface(`Kirim/reply video dengan caption ${command}`);
			}
			break;
		case "ttp":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			//if (isLimit(sender, isPremium, isOwner, limitCount, limit)) return replyDeface(`Limit kamu sudah habis silahkan kirim ${prefix}limit untuk mengecek limit`)
			if (args.length < 0)
				return replyDeface(
					`Gunakan dengan cara ${command} text\n\nContoh : ${command} setya`
				);
			if (q.length > 75) return replyDeface(`Teksnya terlalu panjang`);
			//addCountCmd(`${prefix}ttp`, sender, _cmd)
			var data = await getBuffer(
				`https://api.itsrose.my.id/others/ttp?text=${encodeURIComponent(q)}`
			);
			await sock.sendMessage(
				from,
				{
					sticker: {
						url: await writeExifImg(data, {
							packname: "njir",
							author: "wkwk",
						}),
					},
				},
				{
					quoted: msg,
				}
			);
			break;
		case "attp":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			//if (isLimit(sender, isPremium, isOwner, limitCount, limit)) return replyDeface(`Limit kamu sudah habis silahkan kirim ${prefix}limit untuk mengecek limit`)
			if (args.length < 0)
				return replyDeface(
					`Gunakan dengan cara ${command} text\n\nContoh : ${command} setya`
				);
			if (q.length > 75) return replyDeface(`Teksnya terlalu panjang`);
			//addCountCmd(`${prefix}attp`, sender, _cmd)
			var data = await getBuffer(
				`https://api.itsrose.my.id/others/attp?text=${encodeURIComponent(q)}`
			);
			let buffers = await writeExifVid(data, {
				packname: "njir",
				author: "wkwk",
			});
			await sock.sendMessage(
				from,
				{
					sticker: {
						url: buffers,
					},
				},
				{
					quoted: msg,
				}
			);
			break;
		case "emojimix":
		case "mixemoji":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			//if (isLimit(sender, isPremium, isOwner, limitCount, limit)) return replyDeface(`Limit kamu sudah habis silahkan kirim ${prefix}limit untuk mengecek limit`)
			if (args.length < 0)
				return replyDeface(
					`Gunakan dengan cara ${command} emoji1+emoji2\n\nContoh : ${command} 😅+😝`
				);
			var packname = `${ownerName}`;
			var author = `${botName}`;
			var emo1 = q.split("+")[0];
			var emo2 = q.split("+")[1];
			if (!isEmoji(emo1) || !isEmoji(emo2))
				return replyDeface(`Itu bukan emoji!`);
			//addCountCmd(`${prefix}emojimix`, sender, _cmd)
			fetchJson(
				`https://tenor.googleapis.com/v2/featured?key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&contentfilter=high&media_filter=png_transparent&component=proactive&collection=emoji_kitchen_v5&q=${encodeURIComponent(
					emo1
				)}_${encodeURIComponent(emo2)}`
			)
				.then((data) => {
					sendStickerFromUrl(from, data.results[0].url, packname, author, {
						quoted: msg,
					});
					//limitAdd(sender, limit)
				})
				.catch((e) => replyDeface(mess.error.api));
			break;

		case "sticker":
		case "s":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!isImage && !isQuotedImage && !isVideo && !isQuotedVideo)
				return reply(
					`Kirim media dengan caption ${
						prefix + command
					} atau tag media yang sudah dikirim`
				);
			var stream = await downloadContentFromMessage(
				msg.message[mediaType],
				mediaType.replace("Message", "")
			);
			let stickerStream = new PassThrough();
			if (isImage || isQuotedImage) {
				ffmpeg(stream)
					.on("start", function (cmd) {
						console.log(`Started : ${cmd}`);
					})
					.on("error", function (err) {
						console.log(`Error : ${err}`);
					})
					.on("end", function () {
						console.log("Finish");
					})
					.addOutputOptions([
						`-vcodec`,
						`libwebp`,
						`-vf`,
						`scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`,
					])
					.toFormat("webp")
					.writeToStream(stickerStream);
				sock.sendMessage(from, { sticker: { stream: stickerStream } });
			} else if (isVideo || isQuotedVideo) {
				ffmpeg(stream)
					.on("start", function (cmd) {
						console.log(`Started : ${cmd}`);
					})
					.on("error", function (err) {
						console.log(`Error : ${err}`);
					})
					.on("end", async () => {
						sock
							.sendMessage(from, {
								sticker: { url: `./temp/stickers/${sender}.webp` },
							})
							.then(() => {
								fs.unlinkSync(`./temp/stickers/${sender}.webp`);
								console.log("Finish");
							});
					})
					.addOutputOptions([
						`-vcodec`,
						`libwebp`,
						`-vf`,
						`scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`,
					])
					.toFormat("webp")
					.save(`./temp/stickers/${sender}.webp`);
			}
			break;

		// Search Menu
		case "ffid":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!args[0]) return reply(`Example : \n${prefix + command} 946716486`);
			if (!Number(args[0])) return reply("Hanya angka");
			let dede = await xzons.nickff(args.join(" "));
			epep = `*🔎 FREE FIRE 🔍*\n\nID : ${q}\nNICK :  ${dede.username}`;
			reply(epep);
			break;
		case "mlid":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			let args1_ = q.split("/")[0];
			let args2_ = q.split("/")[1];
			if (!q) return reply(`Example : \n${prefix + command} 617243212/8460`);
			if (!Number(args1_) && !Number(args2_)) return reply("Hanya angka");
			let deede = await xzons.nickml(args1_, args2_);
			let mlb = `*🔎 MOBILE LEGENDS 🔍*

ID : ${q}
Nick : ${deede.userName}`;
			reply(mlb);
			break;
		case "pubgid":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!q)
				return replyDeface(
					`Gunakan dengan cara ${
						prefix + command
					} *id*\n\n_Contoh_\n\n${command} 5217933016`
				);
			axios
				.get(`https://api.lolhuman.xyz/api/pubg/${q}?apikey=${apikey}`)
				.then(({ data }) => {
					let pubg = `*🔎 PUBG MOBILE 🔍*

ID : ${q}
Nick : ${data.result}`;
					replyDeface(pubg);
				})
				.catch((err) => {
					console.log(color("[ ERROR ]", "red"), err);
					replyDeface(mess.error.api);
					setya.sendMessage(ownerNumber, { text: `${command} error : ${err}` });
				});
			break;
		case "higgsid":
			if (!isGroup) return replyDeface(mess.OnlyGrup);
			if (!q)
				return replyDeface(
					`Gunakan dengan cara ${
						prefix + command
					} *id*\n\n_Contoh_\n\n${command} 291756557`
				);
			axios
				.get(
					`https://v1.apigames.id/merchant/M220515ALZM2045XZ/cek-username/higgs?user_id=${q}&signature=6ffbc2d3102edf02c5482bac8c5ab9da`
				)
				.then(({ data }) => {
					let domino = `*🔎 HIGGS DOMINO 🔍*

ID : ${q}
Nick : ${data.data.username}`;
					replyDeface(domino);
				})
				.catch((err) => {
					console.log(color("[ ERROR ]", "red"), err);
					replyDeface(mess.error.api);
					setya.sendMessage(ownerNumber, { text: `${command} error : ${err}` });
				});
			break;

		case "listadmin":
			if (!isGroup) return;
			let teks = `List Admin Group ${groupMetadata.subject}\nTotal : ${groupAdmins.length}\n\n`;
			let no = 0;
			for (let admon of groupAdmins) {
				no += 1;
				teks += `[${no.toString()}] @${admon.split("@")[0]}\n`;
			}
			mentions(teks, groupAdmins, true);
			break;

		case "setthumb":
			if (!isOwner) return reply(`*Khusus Owner*`);
			let medifa = await downloadAndSaveMediaMessage(
				"image",
				`./temp/logo.jpg`
			);
			replyDeface(`*Sukses SetThumb*`);
			break;

		case "setvideo":
			if (!isOwner) return reply(`*Khusus Owner*`);
			let mediaa = await downloadAndSaveMediaMessage(
				"video",
				`./temp/setya.mp4`
			);
			replyDeface(`*Sukses SetThumbVideo*`);
			break;

		case "mla":
			if (!q) return reply(`${command} CODE ID SERVER`);
			if (!isOwner)
				return reply(`Perintah ini hanya bisa digunakan oleh owner bot`);
			try {
				
				tokoVoucher.produk = `MLA${args[0]}`;
				tokoVoucher.id = args[1]
				tokoVoucher.server = args[2]
				const mla = await tokoVoucher.transaksi();
				console.log(mla)
				let msg_
				if (mla.status === "pending") {
					msg_ = "*Order sedang diproses*"
					webHook(from, mla.ref_id, msg, {
						game: "Mobile Legends",					
						oid: `${args[1]} (${args[2]})`,
						item: `${args[0]} Diamonds`,
						date: tanggal,
					})
				}
				else if (mla.status === "sukses") {
					msg_ = "*Terima Kasih Sudah Order*"
				}
				else {
					msg_ = "*Transaksi gagal diproses*"
					if (mla.sn === 'Produk tidak ditemukan') {
						msg_ += '\n_Produk tidak ditemukan_'
					}
				}
				reply(`*[ Transaksi ${mla.status} ]*

*› Game* : Mobile Legends
*› Order ID* : ${args[1]} (${args[2]})
*› Item* : ${args[0]} Diamonds
*› Date* : ${tanggal}
*› RefId* : ${mla.ref_id}

${msg_}

_*${botName}*_
	`)
			} catch {
				reply("Gagal :(")
			}
			break;

			case "mlb":
			if (!q) return reply(`${command} 86 181619598 2951`);
			if (!isOwner)
				return reply(`Perintah ini hanya bisa digunakan oleh owner bot`);
			try {
				
				tokoVoucher.produk = `MLB${args[0]}`;
				tokoVoucher.id = args[1]
				tokoVoucher.server = args[2]
				const mlb = await tokoVoucher.transaksi();
				console.log(mlb)
				let msg_
				if (mlb.status === "pending") {
					msg_ = "*Order sedang diproses*"
					webHook(from, mlb.ref_id, msg, {
						game: "Mobile Legends",					
						oid: `${args[1]} (${args[2]})`,
						item: `${args[0]} Diamonds`,
						date: tanggal,
					})
				}
				else if (mlb.status === "sukses") {
					msg_ = "*Terima Kasih Sudah Order*"
				}
				else {
					msg_ = "*Transaksi gagal diproses*"
					if (mlb.sn === 'Produk tidak ditemukan') {
						msg_ += '\n_Produk tidak ditemukan_'
					}
				}
				await reply(`*[ Transaksi ${mlb.status} ]*

*› Game* : Mobile Legends
*› Order ID* : ${args[1]} (${args[2]})
*› Item* : ${args[0]} Diamonds
*› Date* : ${tanggal}
*› RefId* : ${mlb.ref_id}

${msg_}

_*${botName}*_
	`)
			} catch (e) {
				console.log(e)
				reply("Gagal :(")
			}
			break;

		case "mlc":
			if (!q) return reply(`${command} 86 181619598 2951`);
			if (!isOwner)
				return reply(`Perintah ini hanya bisa digunakan oleh owner bot`);
			try {
				
				tokoVoucher.produk = `MLD${args[0]}`;
				tokoVoucher.id = args[1]
				tokoVoucher.server = args[2]
				const mlc = await tokoVoucher.transaksi();
				console.log(mlc)
				let msg_
				if (mlc.status === "pending") {
					msg_ = "*Order sedang diproses*"
					webHook(from, mlc.ref_id, msg, {
						game: "Mobile Legends",				
						oid: `${args[1]} (${args[2]})`,
						item: `${args[0]} Diamonds`,
						date: tanggal,
					})
				}
				else if (mlc.status === "sukses") {
					msg_ = "*Terima Kasih Sudah Order*"
				}
				else {
					msg_ = "*Transaksi gagal diproses*"
					if (mlc.sn === 'Produk tidak ditemukan') {
						msg_ += '\n_Produk tidak ditemukan_'
					}
				}
				await reply(`*[ Transaksi ${mlc.status} ]*

*› Game* : Mobile Legends
*› Order ID* : ${args[1]} (${args[2]})
*› Item* : ${args[0]} Diamonds
*› Date* : ${tanggal}
*› RefId* : ${mlc.ref_id}

${msg_}

_*${botName}*_
	`)
			} catch (e) {
				console.log(e)
				reply("Gagal :(")
			}
			break;

		case "mld":
			if (!q) return reply(`${command} CODE ID SERVER`);
			if (!isOwner)
				return reply(`Perintah ini hanya bisa digunakan oleh owner bot`);
			try {
				
				tokoVoucher.produk = `GPMBL${args[0]}`;
				tokoVoucher.id = args[1]
				tokoVoucher.server = args[2]
				const mld = await tokoVoucher.transaksi();
				console.log(mld)
				let msg_
				if (mld.status === "pending") {
					msg_ = "*Order sedang diproses*"
					webHook(from, mld.ref_id, msg, {
						game: "Mobile Legends",					
						oid: `${args[1]} (${args[2]})`,
						item: `${args[0]} Diamonds`,
						date: tanggal,
					})
				}
				else if (mld.status === "sukses") {
					msg_ = "*Terima Kasih Sudah Order*"
				}
				else {
					msg_ = "*Transaksi gagal diproses*"
					if (mld.sn === 'Produk tidak ditemukan') {
						msg_ += '\n_Produk tidak ditemukan_'
					}
				}
				await reply(`*[ Transaksi ${mld.status} ]*

*› Game* : Mobile Legends
*› Order ID* : ${args[1]} (${args[2]})
*› Item* : ${args[0]} Diamonds
*› Date* : ${tanggal}
*› RefId* : ${mld.ref_id}

${msg_}

_*${botName}*_
	`)
			} catch (e) {
				console.log(e)
				reply("Gagal :(")
			}
			break;

		case "ff":
			if (!q) return reply(`${command} 720 181619598`);
			if (!isOwner)
				return reply(`Perintah ini hanya bisa digunakan oleh owner bot`);
			let sn,ref_id;
			try {
				tokoVoucher.produk = `FF${args[0]}`;
				tokoVoucher.id = args[1]
                tokoVoucher.server = false
				const ff = await tokoVoucher.transaksi();
				console.log(ff)
				let msg_
				if (ff.status === "pending") {
					msg_ = "*Order sedang diproses*"
					webHook(from, ff.ref_id, msg, {
						game: "Free Fire",
						nick: false,
						oid: `${args[1]} (${args[2]})`,
						item: `${args[0]} Diamonds`,
						date: tanggal,
					})
				}
				else if (ff.status === "sukses") {
					msg_ = "*Terima Kasih Sudah Order*"
				}
				else {
					msg_ = "*Transaksi gagal diproses*"
					if (ff.sn === 'Produk tidak ditemukan') {
						msg_ += '\n_Produk tidak ditemukan_'
					}
				}
				await reply(`*[ Transaksi ${ff.status} ]*

*› Game* : Free Fire
*› Order ID* : ${args[1]}
*› Item* : ${args[0]} Diamonds
*› Date* : ${tanggal}
*› RefId* : ${ff.ref_id}

${msg_}

_*${botName}*_
	`)
			} catch (e) {
				console.log(e)
				reply("Gagal :(")
			}
			break;

		case "react":
			{
				if (!isGroup) return replyDeface(mess.OnlyGrup);
				if (!m.isQuotedMsg) return reply("Reply pesanya!");
				if (!args[0]) return reply("Masukan emoji react!");
				var isBot = m.quotedMsg.sender === botNumber;
				setya.sendMessage(from, {
					react: {
						text: args[0],
						key: { remoteJid: from, fromMe: isBot, id: m.quotedMsg.id },
					},
				});
			}
			break;

		case "runtime":
			var button = [
				{ buttonId: `.owner`, buttonText: { displayText: `OWNER` }, type: 1 },
			];
			setya.sendMessage(from, {
				text: `${runtime(process.uptime())}`,
				buttons: button,
				footer: "RUNTIME BOT",
			});
			break;

		case "backupfile":
			if (!isOwner) return;
			setya.sendMessage(
				from,
				{
					document: fs.readFileSync("./database/sewa.json"),
					mimetype: "application/json",
					fileName: `sewa.json`,
				},
				{ quoted: m }
			);
			setya.sendMessage(
				from,
				{
					document: fs.readFileSync("./database/list-message.json"),
					mimetype: "application/json",
					fileName: `list-message.json`,
				},
				{ quoted: m }
			);
			break;

		case "mute":
		case "botoff":
			if (!isGroup) return reply(`Bot Hanya Respon Di Dalam Group`);
			if (!isOwner && !isGroupAdmins)
				return reply(`Command ${command} Hanya Khusus Admin`);
			if (!isBotGroupAdmins) return reply(`Bot Bukan Admin Group`);
			if (isMuted) return reply(`udah mute`);
			mute.push(from);
			fs.writeFileSync("./database/mute.json", JSON.stringify(mute));
			reply(
				`Sukses Offline Di Group ${groupName}\n\nCatatan :\nAdmin group telah mengaktifkan fitur mute atau bot on/off, mute = bot hanya merespon yg di perintahkan oleh admin group saja`
			);
			break;
		case "produk":
			return;
			const result = await tokoVoucher.cekProduk();
			let listSections = [];
			if (args[0].toLowerCase() === "ml") {
				result.ml.map((v) => {
					listSections.push({
						title: v.nama_produk,
						rowId: "None",
						description: `Code: ${v.code}\nHarga: ${v.price}\nJenis: ${v.jenis_name}`,
					});
				});
				const listMessage = {
					text: "\nMobile Legends\nList harga\n",
					footer: "footer",
					title: "List Produk",
					buttonText: "Choose",
					sections: [
						{
							title: "Query : *" + q,
							rows: listSections,
						},
					],
				};
				return await sock.sendMessage(from, listMessage);
			}

		default:
			if (budy && ["p", "Proses", "P"].includes(budy) && !isCmd) {
				if (!isGroup) return;
				if (!isOwner && !isGroupAdmins) return;
				let proses = `O━• *Transaksi Proses* •━O

${gy}🎉 Status : Pending
?? Mohon Di Tunggu
📆 ${tanggal}
⏰ ${jam}${gy}

📜 *Pesanan @${msg.sender.replace(/[^0-9]/g, "")} Pending Mohon Di Tunggu*
━O━O━••••••••••••━O━O━`;
				const getTextP = getTextSetProses(from, set_proses);
				if (getTextP !== undefined) {
					mentions(
						getTextP
							.replace("@pesanan", rm.quoted.text)
							.replace("user", rm.quoted.sender.split("@")[0])
							.replace("@jam", jam)
							.replace("@tanggal", tanggal),
						[msg.sender],
						true
					);
				} else {
					mentions(proses, [msg.sender], true);
				}
			}

			if (budy && ["d", "Done", "D"].includes(budy) && !isCmd) {
				if (!isGroup) return;
				if (!isOwner && !isGroupAdmins) return;
				let sukses = `O━• *Transaksi Sukses* •━O

${gy}🎉 Status : Sukses
📆 ${tanggal}
⏰ ${jam}${gy}

📜 *Pesanan @${msg.sender.replace(/[^0-9]/g, "")} Sudah Sukses*
━O━O━••••••••••••━O━O━`;
				const getTextD = getTextSetDone(from, set_done);
				if (getTextD !== undefined) {
					mentions(
						getTextD
							.replace("@pesanan", rm.quoted.text)
							.replace("user", msg.sender.replace(/[^0-9]/g, ""))
							.replace("@jam", jam)
							.replace("@tanggal", tanggal),
						[msg.sender],
						true
					);
				} else {
					mentions(sukses, [msg.sender], true);
				}
			}

			if (budy && ["bot", "Bot", "Bit"].includes(budy) && !isCmd) {
				if (!isGroup) return;
				const getTextBot = getTextSetBot(from, set_bot);
				if (getTextBot !== undefined) {
					setya.sendMessage(from, { text: getTextBot });
				} else {
					setya.sendMessage(from, {
						text: `*Iya Sayang Kenapa Manggil Aku Mulu Kangen Ya:)*`,
					});
				}
			}
	}
};
let file = require.resolve(__filename);
fs.watchFile(file, () => {
	fs.unwatchFile(file);
	console.log(`New ${__filename}`);
	delete require.cache[file];
	require(file);
});
